本文参考`常量初始化`文档整理.
https://zh.cppreference.com/w/cpp/language/constant_initialization

## 概述:

设置`静态变量`的初值为`编译时常量`.

静态变量:

静态(static)存储期. 这类对象的存储在`程序开始时`分配, 并在`程序结束时`解分配. 这类对象只存在`一个实例`. 所有在`命名空间`(包含`全局命名空间`)作用域声明的`对象`, 加上声明带有`static`或`extern`的`对象`均拥有此`存储期`. 有关拥有此`存储期`的对象的初始化的细节, 见`非局部变量`与`静态局部变量`.

## 解释

如果`静态[或线程局部 (C++11 起)]`变量以`常量初始化`(见下文), 那么就会在`其他所有初始化`之前进行`常量初始化`以取代`零初始化`.

在满足以下`所有条件`时, `变量`或`临时对象 obj`会以`常量初始化`：

- 要么它有`初始化式`, 要么它的`默认初始化`会进行某些初始化, 并且
- 它的初始化完整表达式是`常量表达式`[, 或者当`obj 是对象`时, 该完整表达式也可以为`obj`和`它的子对象`调用`constexpr 构造函数`, 即便这些对象不是`字面类类型` (C++11 起)].

`常量初始化`的效果与其所对应的`初始化`的效果相同, 但保证它在`任何其他静态[或线程局部 (C++11 起)]对象`的初始化前完成, 并可能在编译时进行.

## 注解

编译器也可以对`其他的静态[及线程局部 (C++11 起)]对象`进行`常量初始化`, 前提是它可以保证它们的`值`与`遵循初始化的标准顺序时的结果`相同.

实践中, `常量初始化`在编译时进行, 并将预先计算的对象表示作为`程序映像`的一部分(如`.data`段)存储. 如果变量既为`const`又被`常量初始化`, 那么它的对象表示可存储于`程序映像`的`只读段`(如`.rodata`段).

```c++
#include <iostream>
#include <array>

struct S
{
  static const int c;
};

const int d = 10 * S::c; // 非常量表达式：此 S::c 前没有初始化式, 此初始化在常量初始化之后发生
                          //  vc开`cpp_23`时,`d`是常量
const int S::c = 5;      // 常量初始化, 保证首先发生

int main()
{
  std::cout << "d = " << d << '\n';
  std::array<int, S::c> a1; // OK：S::c 是常量表达式
  std::array<int, d> a2;    // `错误：d 不是常量表达式`; vc开`cpp_23`时,`d`是常量
}
```
