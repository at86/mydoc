https://zhuanlan.zhihu.com/p/335994370
https://zh.cppreference.com/w/cpp/language/reference

## 右值引用

右值引用可用于为临时对象延长生存期（注意，到 const 的左值引用也能延长临时对象生存期，但这些对象无法被修改）. 更重要的是，当函数同时具有右值引用和左值引用的重载时，`右值引用`重载绑定到右值（包含`纯右值`和`亡值`），而`左值引用`重载绑定到`左值`.

### 右值引用通过 std::move 指向左值

std::move 是一个非常有迷惑性的函数，不理解左右值概念的人们往往以为它能把一个变量里的内容移动到另一个变量，但事实上 std::move 移动不了什么，唯一的功能是把左值强制转化为右值，让右值引用可以指向左值。其实现等同于一个类型转换：static_cast<T&&>(lvalue)。

单纯的 std::move(xxx)不会有性能提升，引入右值引用，就是为了移动语义。移动语义就是为了减少拷贝。std::move 就是将左值转为右值引用。这样就可以重载到移动构造函数了，移动构造函数将指针赋值一下就好了，不用深拷贝了，提高性能.

被声明出来的`右值引用`是左值, 因为被声明出的`右值引用`是有地址的，位于等号左边，但是它只能被赋右值。作为函数返回值的 && 是右值，直接声明出来的 && 是左值。

- 从性能上讲，左右值引用没有区别，传参使用左右值引用都可以避免拷贝。
- 右值引用可以直接指向右值，也可以通过 std::move 指向左值；而左值引用只能指向左值(const 左值引用也能指向右值)。
- 作为函数形参时，右值引用更灵活。虽然 const 左值引用也可以做到左右值都接受，但它无法修改，有一定局限性。

## 完美转发 std::forward

和 std::move 一样，它的兄弟 std::forward 也充满了迷惑性，虽然名字含义是转发，但他并不会做转发，同样也是做类型转换.

与 move 相比，forward 更强大，move 只能转出来右值，forward 都可以。

std::forward<T>(u)有两个参数：T 与 u。 a. 当 T 为左值引用类型时，u 将被转换为 T 类型的左值； b. 否则 u 将被转换为 T 类型右值。

上边的示例在日常编程中基本不会用到，std::forward 最主要运于`模版编程`的`参数转发`中，想深入了解需要学习万能引用(T &&)和引用折叠(eg:& && → ?)等知识，本文就不详细介绍这些了。

# 如何评价 C++11 的右值引用（Rvalue reference）特性？ - 知乎

https://www.zhihu.com/question/22111546

## https://www.zhihu.com/question/22111546/answer/159589333

C++11 正式推出的右值引用（Rvalue reference）、濒危值（xvalue）才是真正的新东西，是现在的计算机本科生都该学习的，让男程序员沉默、女程序员流泪什么是右值引用（Rvalue reference）？ 你写一个很简单的几行程序，来个类型显式转换为右值引用或者调用一个完美转发（perfect forward），然后看看编译后对应的汇编语句，就知道在汇编这一层面，右值引用就是当作个指针，完美转发其实啥都没做。

既然右值引用实现时就是个指针，那么它与传统的（左值）引用有什么区别？ 答案是，在汇编层面上，二者没有区别。 （题外话, 如果你的程序动态载入一个 DLL，然后加载 DLL 的一个输出函数，这个函数的某个参数在实现时是传统的（左值）引用，那么你现在只能把它看作指针型参数来使用）。

右值引用在编译器之下的层面就是指针这么简单的东西，那在编译器之上的 C++源代码中，为什么引入右值引用这个新概念？ 我认为，其目的、意义就是让编程者与编译器，能区分两种情形：a. 使用传统左值引用的复制语义 b. 使用右值引用的的移动语义。你把一个对象“移动”方式存入容器对象，别人并不知道这个对象到底该如何“移动”，必须是你来写一个移动构造函数，具体把这个类型的对象的“移动”给实作出来。container.push_back(argument_expression); 这么个语句，编译器就可以根据实参表达式的值分类，来确定应该重载（overload）调用复制语义版本的 push_back（Type& param），还是移动语义版本的 push_back(Type&& param)

## https://www.zhihu.com/question/22111546/answer/26807443

- const& 既可以绑定左值，又可以绑定右值，
- & 只可以绑定左值。

## https://www.zhihu.com/question/22111546/answer/1938472911

右值引用可以更好地支持 move。因为 move 只可以移动右值。C++17 对 value categories 做了完善，所以本回答做一个补充，move prvalue 时可以实体化生成临时变量，从而被 move。xvalue 则可以直接 move。如果需要移动左值，就要用 std::move 作用于左值，然后移动。返回值属于 prvalue，所以不用再移动了。
