本文参考`聚合初始化`文档整理.
https://zh.cppreference.com/w/cpp/language/aggregate_initialization

## 概述:

从`初始化式列表`初始化`聚合体`. 此为`列表初始化`的一种形式. (C++11 起)

我的总结:

## 语法

- `T 对象 = { 实参1, 实参2, ... };` (1)
- `T 对象 { 实参1, 实参2, ... };` (2) (C++11 起)
- `T 对象 = { .指派符1 = 实参1 , .指派符2 { 实参2 } ... };` (3) (C++20 起)
- `T 对象 { .指派符 1 = 实参 1 , .指派符 2 { 实参 2 } ... };` (4) (C++20 起)

  1,2) 用通常的`初始化式列表`初始化聚合体.
  3,4) 用`指派初始化式`初始化聚合体（仅支持`聚合类`）.

## 解释

`聚合体`是下列类型之一:

- 数组类型
- 符合以下条件的`类类型`（通常是 struct 或 union）
  - 没有`用户`声明的`构造函数` (C++11 前)
  - 没有`用户`提供,继承或`explicit`的`构造函数` (C++11 起) (C++20 前)
  - 没有`用户`声明或继承的`构造函数` (C++20 起)
  - 没有`私有`或`受保护的`[直接(C++17 起)]非静态`数据`成员
  - 没有`基类` (C++17 前)
  - 没有`虚基类` (C++17 起)
  - 没有`私有或受保护`的`直接基类` (C++17 起)
  - 没有`虚成员函数`
  - 没有`默认成员初始化式` (C++11 起) (C++14 前)

聚合体的`元素`有:

- 对于`数组`, 按下标顺序包含所有数组元素, 或者,
- 对于`类`, 按`声明顺序`包含所有不是匿名位域的非静态`数据成员`. (C++17 前)
- 对于`类`, 按`声明顺序`包含所有`直接基类`, 然后按声明顺序包含所有不是`匿名位域`或`匿名联合体成员`的非静态`数据成员`. (C++17 起)

### 聚合初始化的效果是:

1. 拒绝下列非良构场合:
   - 初始化式列表中的`初始化式子句`数`多于`聚合体中的`元素`数, 或
   - 以`空初始化式列表`（{}）初始化`边界未知`的数组.

```c++
 char cv[4] = {'a', 's', 'd', 'f', 0}; // 错误
 int x[] = {}; // 错误
```

2. 按以下规则决定`显式初始化元素`:

   - 如果初始化式列表是`指派初始化式列表`（聚合体此时只能具有`类类型`）, 每个`指派符`中的`标识符`必须指名该类的一个非静态`数据成员`, 并且聚合体中`显式初始化元素`是这些成员或包含这些成员的元素. (C++20 起)
   - 否则, 如果初始化式列表不为空, 那么`显式初始化元素`是聚合体中的`前 n`个元素, 其中`n`是`初始化式列表`中的元素数量.
   - 否则初始化式列表`必须为空`, 并且`不存在`显式初始化元素.

     如果聚合体是联合体并且显式初始化元素不止一个, 那么程序非良构:

```c++
  union u { int a; const char\* b; };

u a = {1}; // OK: 显式初始化成员 a
u b = {0, "asdf"}; // 错误: 显式初始化两个成员
u c = {"asdf"}; // 错误: 不能以 "asdf" 初始化 int

// C++20 指派初始化式列表
u d = {.b = "asdf"}; // OK: 可以显式初始化非开头元素
u e = {.a = 1, .b = "asdf"}; // 错误: 显式初始化两个成员
```

3. [按元素顺序 (C++11 起)]初始化聚合体中的每个元素. [也就是说, 给定`某个元素`, 它`关联的所有的值计算和副作用`都会按顺序`早于`按顺序在它`之后`的所有元素`关联的所有的值计算和副作用`. (C++11 起)]

### 元素初始化

#### 对于每个`显式初始化元素`:

- 如果该元素是`匿名联合体成员`, 并且初始化式列表是`指派初始化式列表`, 那么该元素会被指`派初始化式列表 {D}`初始化, 其中`D`是指名该匿名联合体成员的成员的`指派初始化式子句`. 只能有`一个`这样的`指派初始化式子句`.(C++20 起)

```c++
struct C
{
  union
  {
    int a;
    const char* p;
  };
  int x;
} c = {.a = 1, .x = 3}; // 以 1 初始化 c.a 并且以 3 初始化 c.x
```

- 否则, 该`元素`会以初始化式列表中`对应`的初始化式子句`复制初始化`: (C++20 前)
- 否则, 该`元素`会以初始化式列表中`对应`的初始化式子句`初始化`. 如果初始化式列表是`指派初始化式列表`并且`初始化式`不以`=`开始, 那么该初始化是`直接初始化`, 否则该初始化是`复制初始化`: (C++20 起)
  - 如果该`初始化式子句`是`表达式`, 那么该`复制初始化`允许`隐式`转换[, 但禁止`窄化`转换 (C++11 起)].
  - 如果该`初始化式子句`是`嵌套`的花括号初始化式列表（不是表达式）, 那么[以该子句`列表初始化`该对应元素, 它会 (C++11 起)]在该`对应`元素是子聚合体时`递归`应用此规则.

```c++
struct A
{
    int x;

    struct B
    {
        int i;
        int j;
    } b;
} a = {1, {2, 3}}; // 以 1 初始化 a.x，以 2 初始化 a.b.i，以 3 初始化 a.b.j

struct base1 { int b1, b2 = 42; };

struct base2
{
    base2()
    {
        b3 = 42;
    }

    int b3;
};

struct derived : base1, base2
{
    int d;
};

derived d1{{1, 2}, {}, 4}; // 以  1 初始化 d1.b1，以 2 初始化 d1.b2，
                           //             以 42 初始化 d1.b3，以 4 初始化 d1.d
derived d2{{}, {}, 4};     // 以  0 初始化 d2.b1，以 42 初始化 d2.b2，
                           //             以 42 初始化 d2.b3，以  4 初始化 d2.d

```

#### 对于`不是联合体`的`聚合体`, 每个`没有`显式初始化的`元素`会按以下规则初始化:

- 如果该`元素`有`默认成员初始化式`, 那么以该`初始化式`初始化该元素. (C++11 起)
- 否则, 如果该`元素`不是引用, 那么以`空初始化式`列表`复制初始化`该元素.
- 否则程序非良构.

```c++
struct S
{
    int a;
    const char* b;
    int c;
    int d = b[a];
};

// 以 1 初始化 ss.a，
// 以 "asdf" 初始化 ss.b，
// 以表达式 int{} 的值（0）初始化 ss.c，
// 以 ss.b[ss.a] 的值（'s'）初始化 ss.d
S ss = {1, "asdf"};
```

#### 如果聚合体为`联合体`且该`初始化式列表为空`, 则

- 如果有任何`可变成员`具有`默认成员初始化式`, 则该成员以其`默认成员初始化式`初始化.(C++11 起)
- 否则, 联合体的`首个成员`（如果有）以`空初始化式列表`进行`复制初始化`.

### 花括号消除

可消除（省略）环绕嵌套的初始化式列表的`花括号`, 这种情况下, 使用`所需数量`的`初始化式子句`初始化对应的`子聚合体`的各个成员或元素, 而后继的各个`初始化式子句`被用来初始化对象中的后续成员. 然而, 如果对象拥有`不带任何成员`的子聚合体（`空结构体`, 或只保有`静态成员`的结构体）, 那么`不允许`消除花括号而必须使用一个`空的`嵌套列表 {}.

### 指派初始化式 (C++20 起)

语法形式 (3,4) 被称为`指派初始化式`: 每个`指派符`必须指名`T`的一个`直接`非静态`数据成员`, 而表达式中所用的所有`指派符`必须按照与`T`的数据成员`相同的顺序`出现.

```c++
struct A { int x; int y; int z; };

A a{.y = 2, .x = 1}; // 错误: 指派符的顺序不匹配声明顺序
A b{.x = 1, .z = 2}; // OK: b.y 被初始化为 0
```

`指派初始化式`所指名的每个`直接`非静态`数据成员`, 从它的指派符后随的`对应花括号`或`等号初始化式`初始化. 禁止`窄化`转换.
`指派初始化式`可以用来将`联合体`初始化为它的`首个成员`之外的状态. 只可以为一个`联合体`提供`一个`初始化式.

```c++
union u { int a; const char\* b; };

u f = {.b = "asdf"}; // OK: 联合体的活跃成员是 b
u g = {.a = 1, .b = "asdf"}; // 错误: 只可提供一个初始化式
```

对于`非联合体`的聚合体中`未提供`指派初始化式的元素, 按上述针对初始化式子句的`数量`少于`成员数量`时的规则进行初始化（如果提供`默认成员初始化式`就使用它, 否则用`空列表`进行初始化）:

```c++
struct A
{
string str;
int n = 42;
int m = -1;
};

A{.m = 21} // 以`{}`初始化 str, 这样会调用默认构造函数
          // 然后以 = 42 初始化 n
          // 然后以 = 21 初始化 m
```

如果以`指派初始化式`子句初始化的聚合体拥有一个`匿名联合体成员`, 那么对应的`指派初始化式`必须指名该`匿名联合体`的其中一个成员.

注意: 乱序的指派初始化,嵌套的指派初始化,指派初始化式与常规初始化式的混合, 以及数组的指派初始化在 C 编程语言中受支持, 但在 C++ 不允许.

```c++
struct A { int x, y; };
struct B { struct A a; };

struct A a = {.y = 1, .x = 2}; // C 中合法, C++ 中非法（乱序）
int arr[3] = {[1] = 5}; // C 中合法, C++ 中非法（数组）
struct B b = {.a.x = 0}; // C 中合法, C++ 中非法（嵌套）
struct A a = {.x = 1, 2}; // C 中合法, C++ 中非法（混合）
```

### 字符数组

`普通字符类型`（char,signed char,unsigned char）,`char8_t (C++20 起)`,`char16_t`,`char32_t (C++11 起)`或`wchar_t`的`数组`能分别从`普通字符串字面量`,`UTF-8 字符串字面量 (C++20 起)`,`UTF-16 字符串字面量`,`UTF-32 字符串字面量 (C++11 起)`或`宽字符串字面量`初始化, 可以以`花括号`环绕. [另外, `char`或`unsigned char`的`数组`可以由`UTF-8 字符串字面量`初始化, 可用`花括号`环绕字符串字面量. (C++20 起)]字符串字面量的相继字符（包含隐含的空终止字符）初始化各数组元素. 如果指定了`数组大小`且`大于`字符串字面量中的`字符数`, 那么剩余字符会被`零初始化`.

```c++
char a[] = "abc";
// 等价于 char a[4] = {'a', 'b', 'c', '\0'};

// unsigned char b[3] = "abc"; // 错误: 初始化式字符串太长
unsigned char b[5]{"abc"};
// 等价于 unsigned char b[5] = {'a', 'b', 'c', '\0', '\0'};

wchar_t c[] = {L"кошка"}; // 花括号可以省略
// 等价于 wchar_t c[6] = {L'к', L'о', L'ш', L'к', L'а', L'\0'};
```

### 注解

`聚合类`或`数组`可以包含非聚合的[公开基类, (C++17 起)]成员或元素, 它们以上述方式初始化（例如从对应的初始化式子句`复制初始化`）.

C++11 前, 聚合初始化中曾`允许`窄化转换, 但此后`不再`被允许.

C++11 前, 由于语法限制, 聚合初始化只能用于`变量定义`, 而不能用于`构造函数初始化列表`, `new 表达式`或`临时对象创建`.

C 中, 长度比字符串字面量的大小`少一`的`字符数组`可以从字符串字面量初始化；产生的数组是`非空终止`的. 这在 C++ 中不允许.
