本文参考`直接初始化`文档整理.
https://zh.cppreference.com/w/cpp/language/direct_initialization

## 概述：

以一组明确的构造函数`实参`对`对象`进行初始化.

我的总结:

- 用`目标`类类型可匹配的`构造函数`, 直接初始化`对象`或`纯右值`
- 用`实参`类类型的`转换函数`, 直接初始化`对象`或`纯右值`
- 用`构造函数`的`成员初始化式列表`, 直接初始化`数据成员`
- 用`static_cast 表达式`, 直接初始化`纯右值`
- 用带`非空初始化式`的`new`表达式, 直接初始化具有`动态存储期`的对象
- 用`lambda`表达式的`按复制捕获`的变量, 直接初始化`闭包对象的成员`

## 语法

- `T 对象 ( 实参 );` `T 对象 ( 实参1, 实参2, ... );` (1)
- `T 对象 { 实参 };` (2) (C++11 起)
- `T ( 其他对象 )` `T ( 实参 1, 实参 2, ... )` (3)
- `static_cast< T >( 其他对象 )` (4)
- `new T(实参列表, ...)` (5)
- `类::类() : 成员(实参列表, ...) { ... }` (6)
- `[实参](){ ... }` (7) (C++11 起)

语法解释：

1. 以`表达式`[或`花括号初始化列表`(C++11 起)]的非空`带括号`列表,初始化`对象`.
2. 以`花括号`环绕的`单个初始化式`初始化一个`非类类型`对象（注意：对于`类类型`和其他使用`花括号初始化列表`的初始化, 见`列表初始化`）.
3. 用`函数式转型`或以`带括号`的表达式列表初始化[[`纯右值`临时量(C++17 前)]/[`纯右值`的结果对象(C++17 起)]].
4. 用`static_cast 表达式`初始化[[`纯右值`临时量(C++17 前)]/[`纯右值`的结果对象(C++17 起)]].
5. 用带有`非空初始化式`的`new 表达式`初始化具有`动态存储期`的对象.
6. 用构造函数`成员初始化式列表`初始化`基类`或`非静态成员`.
7. 在`lambda 表达式`中从`按复制捕获`的变量初始化`闭包对象的成员`.

### 直接初始化的效果是：

- 如果 T 是`数组类型`:

  - 程序非良构. (C++20 前)
  - 按`聚合初始化`初始化`数组`, 但允许`窄化转换`, 并`值初始化`任何`不带初始化式`的元素. (C++20 起)

    ```c++
    struct A {
      explicit A(int i = 0) {}
    };
    A a[2](A(1)); // OK：以 A(1) 初始化 a[0] 并以 A() 初始化 a[1]
    A b[2]{A(1)}; // 错误：从 {} 隐式复制初始化 b[1] 选择了 explicit 构造函数
    ```

- 如果 T 是`类类型`:

  - 如果`初始化式`是`纯右值`表达式且类型与 T 为`相同的类`（忽略 cv 限定）, 则用`初始化式表达式自身`, 而非从它实质化的临时量, 初始化`目标`对象：（C++17 前, 编译器可以在此情况下消除源自`纯右值`的构造, 但适合的构造函数仍必须可访问：参阅`复制消除`）(C++17 起)
  - 检验 T 的`构造函数`并由重载决议选取最佳匹配. 然后调用该`构造函数`以初始化对象.
  - 否则, 如果`目标`类型是（可能有 cv 限定）的`聚合类`, 则按`聚合初始化`中所述进行初始化, 但允许`窄化转换`, 不允许使用`指派初始化式`, 不延长引用所绑定到的临时量的生存期, 不进行花括号消除, 并`值初始化`任何`无初始化式的元素`. (C++20 起)

    ```c++
    struct B
    {
        int a;
        int&& r;
    };

    int f();
    int n = 10;

    B b1{1, f()};            // OK：延长生存期
    B b2(1, f());            // 良构，但有悬垂引用
    B b3{1.0, 1};            // 错误：窄化转换
    B b4(1.0, 1);            // 良构，但有悬垂引用
    B b5(1.0, std::move(n)); // OK
    ```

- 否则, 如果`T`是`非类类型`, 但`源类型`是`类类型`, 则检验源类型及其各基类的`转换函数`, 并由重载决议选取最佳匹配. 然后用选取的`转换函数`, 将`初始化式表达式`转换为所初始化的`T`的对象.
- 否则, 如果`T`是`bool`, 而`源类型`是`std::nullptr_t`, 则被初始化对象的值为`false`.
- 否则, 在必要时使用`标准转换`, 转换`其他对象`的值为`T`的无 cv 限定版本, 而所初始化的对象的初值为（可能为转换后的）该值.

## 注解

`直接初始化`比复制初始化更`宽松`：`复制初始化`仅考虑`非显式`的构造函数和非显式的转换函数, 而`直接初始化`考虑`所有`构造函数和所有转换函数.

在使用`直接初始化语法 (1)（带圆括号）`的变量声明和函数声明之间有`歧义`的情况下, 编译器始终`选择函数声明`. 此消歧义规则有时是反直觉的, 并且已被称为最烦人的分析.

```c++
#include <fstream>
#include <iterator>
#include <string>

int main() {
    std::ifstream file("data.txt");

    // 下面是函数声明：
    std::string foo1(std::istreambuf_iterator<char>(file),
                     std::istreambuf_iterator<char>());
    // 它声明名为 str 的函数，其返回类型为 std::string，
    // 第一参数拥有 std::istreambuf_iterator<char> 类型和名称 "file"
    // 第二参数无名称并拥有类型 std::istreambuf_iterator<char>()，
    // 它被重写成函数指针类型 std::istreambuf_iterator<char>(*)()

    // C++11 前的修正（用以声明变量）：用额外括号环绕其中一个实参
    std::string str1((std::istreambuf_iterator<char>(file)),
                      std::istreambuf_iterator<char>());

    // C++11 后的修正（用以声明变量）：对任意实参使用列表初始化
    std::string str2(std::istreambuf_iterator<char>{file}, {});
}
```
