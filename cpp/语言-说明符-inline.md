本文参考`inline 说明符`文档整理.
https://zh.cppreference.com/w/cpp/language/inline

## 概述：

`inline`说明符, 修饰`类或命名空间(包含全局)`作用域内的`函数`和`变量`, 不能修饰`块作用域(函数内部)`内的函数或变量, 不能重复声明在`翻译单元中`已定义为`非内联的函数[或变量 (C++17 起)]`.

### 内联函数

`inline`说明符, 在用于函数的`声明说明符序列`时, 将函数声明为一个`内联（inline）函数`.
`inline`对于函数的含义已经变为`容许多次定义`而不是`优先内联`. 即`函数的定义`被`多个源文件包含`时, 必须是`inline`的.

隐式的内联函数:

- 声明有`constexpr`的函数是`隐式的内联函数`. (C++11 起)
- 类内`弃置的函数`是`隐式的内联函数`：它的（弃置）定义可以在`多于一个`翻译单元中出现. (C++11 起)
- 类内`隐式`生成的`成员函数`和任何在它的首条声明中`声明为预置`的成员函数是`隐式的内联函数`
- 整个定义都在`class/struct/union`的定义内 **[且被附着到全局模块(C++20 起) todo]** 的函数是`隐式的内联函数`, 无论它是`成员函数`还是`非成员 friend 函数`.

### 内联变量

- `inline`说明符, 在用于具有`静态存储期的变量`（`静态成员变量`或`命名空间作用域变量`）的`声明说明符序列`时, 将变量声明为`内联变量`. (C++17 起)
- 声明为`constexpr`的`静态成员变量`（但不是命名空间作用域变量）是`隐式的内联变量`. (C++17 起)
- `内联变量`消除了将 C++ 代码打包为`只有头文件的库`的主要障碍

### `内联函数[或内联变量 (C++17 起)]`具有下列性质：

- `内联函数[或内联变量 (C++17 起)]`的定义, 必须在访问它的翻译单元中可达（不一定要在访问点前）.
- 带`外部链接`的`内联函数[或内联变量 (C++17 起)]`（例如不声明为 static）拥有下列额外属性：
  - `内联函数[或内联变量 (C++17 起)]`在程序中可以有`多次定义`, 只要每个定义都出现在不同翻译单元中（对于非静态的内联函数和变量 (C++17 起)）且所有定义等同即可. 例如, `内联函数[或内联变量 (C++17 起)]`可以在被多个源文件所`#include`的`头文件中定义`.
  - 它必须在每个翻译单元中都`被声明为 inline` .
  - 它在每个翻译单元中都拥有`相同`的地址.

> **外部链接**: 名字能从其他翻译单元中的作用域使用.

在`内联函数`中:

- 所有函数定义中的`函数局部静态对象`在所有翻译单元间`共享`（它们都指代`相同`的在某一个翻译单元中定义的对象）
- 所有函数定义中所`定义的类型`同样在所有翻译单元中`相同`.

命名空间作用域的`内联 const 变量`默认具有`外部链接`（这点与非内联非 volatile 的有 const 限定的变量不同）(C++17 起)

`inline 关键词`的本意是作为给优化器的指示器, 以指示优先采用函数的内联替换而非进行函数调用, 避免函数调用的开销（传递实参及返回结果）. `inline`的含义是`非强制`的, 编译器拥有, 对任何未标记为`inline`的函数使用: 内联替换的自由, 或生成函数调用的自由. 这些优化选择不改变上述关于`多个定义`和`共享静态变量`的规则.
