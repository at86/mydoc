本文参考`默认初始化`文档整理.
https://zh.cppreference.com/w/cpp/language/default_initialization

## 概述:

`默认初始化`, 是在不使用`初始化式`构造变量时, 执行的初始化.

我的总结:

- 类类型, 必须有`默认构造函数`, 才能默认初始化
- `数组类型`的默认初始化, 对数组的每个`元素`进行默认初始化
- `标量类型`和`POD类类型`, 不能以`T t;`语法`即(自动存储期)`默认初始化, 能以`new T`语法(c++11 起)`即(动态存储期)`默认初始化
- 用`无`初始化式的`new`表达式, 默认初始化具有`动态存储期`的对象
- `引用`不能默认初始化, 如`int& r;`
- `const 对象`的默认初始化, 需要有`用户提供`的`默认构造函数`, 或者数据成员`都有`默认成员初始化式

## 语法

- `T 对象;` (1)
- `new T` (2)

默认初始化在三种情况下进行:

1. 当`不带初始化式`而声明具有`自动、静态或线程局部存储期`的变量时;
2. 当以`不带初始化式`的`new 表达式`创建具有`动态存储期`的对象时`或当以带有由一个空括号对组成的初始化式的 new 表达式创建对象时 (C++03 前)`;
3. 当构造函数`初始化式列表`中`未提及`某个`基类`或`非静态数据成员`, 且调用了该构造函数时.

### 默认初始化的效果是:

- 如果`T`是[非 POD (C++11 前)]类类型, 那么考虑各`构造函数`并实施针对`空实参列表`的重载决议. 调用所选的构造函数(即`默认构造函数`之一), 以提供新对象的初始值;
- 如果`T`是`数组类型`, 那么该数组的`每个元素`都被默认初始化;
- 否则`不进行`默认初始化

## const 对象的默认初始化

如果程序调用有`const 限定类型的 T 对象`的默认初始化, 那么 T 必须是`可 const 默认构造`的`类类型`或`它的数组`.

如果`类类型 T 的默认初始化`会调用`用户提供`[`(不是从基类继承) (C++11 起)`]的 `T 构造函数`, 或满足以下条件, 那么 T `可 const 默认构造`:

- (C++11 前): 当未使用初始化式时, 仅有具有`自动存储期`的(可能 cv 限定的)`非 POD`类类型(或其数组)认为被`默认初始化`. 具有`动态存储期`的`标量`和`POD 类型`则认为`未被初始化`(从 C++11 开始, 这种情况被归类为`默认初始化`的一种形式).

- (C++11 前): T 的每个直接`非静态`数据成员 M 拥有`类类型 X`(或它的数组), X `可 const 默认构造`, 且
- T 没有直接`变体成员`, 且

- (C++11 起): T 的每个直接`非变体非静态`数据成员 M 均拥有`默认成员初始化式`, 或如果 M 拥有`类类型 X`(或它的数组), X `可 const 默认构造`,
- (C++11 起): 如果`T 是`至少拥有一个非静态`数据成员`的`联合体`, 刚好有一个`变体成员`拥有`默认成员初始化式`,
- (C++11 起): 如果 `T 不是联合体`, 那么对于每个至少拥有一个`非静态数据成员`的匿名联合体成员(如果存在), 刚好有一个`非静态数据成员`拥有`默认成员初始化式`, 且

- T 的每个潜在构造的`基类`均`可 const 默认构造`.

## 从不确定字节读取

使用由`默认初始化`任何`非类类型`的变量所取得的`不确定的值`是`未定义行为`(特别是, 它可能是一种陷阱表示), 除了下列情况:

- 将`unsigned char`[`或 std::byte (C++17 起)`]类型的不确定值`赋值给`另一拥有(可有 cv 限定的)`unsigned char`[`或 std::byte (C++17 起)`]类型的变量(变量的值变为不确定, 但该`行为不是未定义`);
- 用`unsigned char`[`或 std::byte (C++17 起)`]类型的不确定值`初始化`另一拥有(可有 cv 限定的)`unsigned char`[`或 std::byte (C++17 起)`]类型的变量;
- 从以下场合产生`unsigned char`[`或 std::byte (C++17 起)`]类型的`不确定值`:
  - 条件表达式的第二或第三操作数,
  - 逗号运算符的右操作数,
  - 转型或转换到(可有 cv 限定的)`unsigned char`[`或 std::byte (C++17 起)`]的操作数,
  - 弃值表达式.

```c++
int f(bool b) {
    int x;               // OK: x 的值不确定
    int y = x;           // 未定义行为
    unsigned char c;     // OK: c 的值不确定
    unsigned char d = c; // OK: d 的值不确定
    int e = d;           // 未定义行为
    return b ? d : 0;    // 如果 b 为 true 则行为未定义
}
```
