本文参考`默认初始化`文档整理.
https://zh.cppreference.com/w/cpp/language/default_initialization

## 概述：

`默认初始化`, 是在不使用`初始化式`构造变量时, 执行的初始化.

通过`文档阅读`和`代码调试`后结论:

- 对于`非POD`类类型, 必须有`默认构造函数`
- `标量类型`和`POD类类型`, 在`T t;`这种`默认初始化`形式时, 虽然实际执行了`默认初始化`, 但编译器会报错`变量未初始化`

## 语法

- `T 对象;` (1)
- `new T` (2)

## 默认初始化在三种情况下进行：

1. 当`不带初始化式`而声明具有`自动、静态或线程局部存储期`的变量时；
2. 当以`不带初始化式`的`new 表达式`创建具有`动态存储期`的对象时`或当以带有由一个空括号对组成的初始化式的 new 表达式创建对象时 (C++03 前)`；
3. 当构造函数`初始化式列表`中`未提及`某个`基类`或`非静态数据成员`，且调用了该构造函数时。

## 默认初始化的效果是：

- 如果`T`是`非 POD (C++11 前)`类类型，那么考虑各`构造函数`并实施针对`空实参列表`的重载决议。调用所选的构造函数（即`默认构造函数`之一），以提供新对象的初始值；
- 如果`T`是`数组类型`，那么该数组的每个元素都被默认初始化；
- 否则`不进行`默认初始化:
  - `引用`不能`默认初始化`, 如`int& r;`
  - `const 标量对象`不能`默认初始化`, 如`const int n;`
  - 带`隐式默认构造函数`的类`T1`不能`const 对象的默认初始化`, 如`const T1 t1;`
  - `POD 类型`不能通过`T 对象;`这种形式`默认初始化`, 编译器提示`变量未初始化`, 如`A a; a.x;`, A 是`POD 类`, `A a;`不报错,但是`a.x;`报错: `使用了未初始化的局部变量“a”`; `int i;`, `i`是`标量类型`,并没有被默认初始化.
  - 具有`自动和动态存储期`的`非类变量`的`默认初始化`有可能产生具有`不确定值`的对象（静态和线程局部对象进行的是零初始化）

## const 对象的默认初始化

如果程序调用有 `const 限定类型的 T 对象`的默认初始化，那么 T 必须是`可 const 默认构造`的`类类型`或`它的数组`。

如果`类类型 T 的默认初始化`会调用`用户提供`[`（不是从基类继承） (C++11 起)`]的 `T 构造函数`，或满足以下条件，那么 T `可 const 默认构造`：

- (C++11 前): 当未使用初始化式时，仅有具有自动存储期的（可能 cv 限定的）非 POD 类类型（或其数组）认为被默认初始化。具有动态存储期的标量和 POD 类型则认为未被初始化（从 C++11 开始，这种情况被归类为默认初始化的一种形式）。

- (C++11 前): T 的每个直接非静态数据成员 M 拥有类类型 X（或它的数组），X `可 const 默认构造`，且
- T 没有直接变体成员，且

- (C++11 起): T 的每个直接非变体非静态数据成员 M 均拥有默认成员初始化式，或如果 M 拥有类类型 X（或它的数组），X `可 const 默认构造`，
- (C++11 起): 如果 T 是至少拥有一个非静态数据成员的联合体，刚好有一个变体成员拥有默认成员初始化式，
- (C++11 起): 如果 T 不是联合体，那么对于每个至少拥有一个非静态数据成员的匿名联合体成员（如果存在），刚好有一个非静态数据成员拥有默认成员初始化式，且

- T 的每个潜在构造的基类均`可 const 默认构造`。

## 从不确定字节读取
