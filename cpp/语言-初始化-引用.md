本文参考`引用初始化`文档整理.
https://zh.cppreference.com/w/cpp/language/reference_initialization

## 概述：

将一个引用`绑定`到一个对象. 

我的总结:


## 语法

**非列表初始化**

- `T& 引用 = 目标;` `T& 引用 ( 目标 );` (1)	
- `T&& 引用 = 目标;` `T&& 引用 ( 目标 );` (2)	(C++11 起)
- `接受引用的函数 ( 目标 )`	(3)	
- `return 目标;`	(4)	(在返回引用的函数的定义中)
- `类::类(...) : 引用成员 ( 目标 ) { ... }`	(5)	(在类的定义中)

**一般列表初始化 (C++11 起)**

- `T& 引用 = { 实参1, 实参2, ... };` `T& 引用 { 实参1, 实参2, ... };` (1)	
- `T&& 引用 = { 实参1, 实参2, ... };` `T&& 引用 { 实参1, 实参2, ... };` (2)	
- `接受引用的函数 ({ 实参1, 实参2, ... });`	(3)	

**指派列表初始化 (C++20 起)**
- `T& 引用 = {.指派符1 = 实参1 , .指派符2 { 实参2 } ... };` `T& 引用 {.指派符1 = 实参1 , .指派符2 { 实参2 } ... };` (1)	
- `T&& 引用 = {.指派符1 = 实参1 , .指派符2 { 实参2 } ... };` `T&& 引用 {.指派符1 = 实参1 , .指派符2 { 实参2 } ... };` (2)	
- `接受引用的函数 ({.指派符1 = 实参1 , .指派符2 { 实参2 } ... });`	(3)	

到`T 的引用`能以`T 类型的对象`,`T 类型的函数`或`可以隐式转换到 T 的对象`初始化. 引用一旦`初始化`, 便`无法`引用另一对象. 

引用在下列情形初始化：

1) 以初始化器声明`具名左值`引用变量时
2) 以初始化器声明`具名右值`引用变量时
3) 在函数调用表达式中且有`函数形参`拥有引用类型时
4) 在函数的 return 语句中且`函数返回`引用类型时
5) 以`成员初始化器`初始化`引用类型`的非静态数据成员时

解释
- T	-	被引用类型
- 引用	-	要初始化的引用变量
- 目标	-	使用的初始化器表达式
- 接受引用的函数	-	参数是引用类型（T& 或 T&& (C++11 起)）的函数
- 返回引用的函数	-	返回类型是引用类型（T& 或 T&& (C++11 起)）的函数
- 类	-	类名
- 引用成员	-	类的引用类型（T& 或 T&& (C++11 起)）非静态数据成员
- 指派符1, 指派符2, ...	-	指派符
- 实参1, 实参2, ...	-	初始化器列表中的初始化器

对于两个类型 T1 和 T2：

- 分别给定 T1 和 T2 的无 cv 限定版本为 U1 和 U2, 如果 U1 与 U2 相似, 或者 U1 是 U2 的基类, 那么 T1 `引用关联`于 T2. 
- 如果类型“指向 T2 的指针”的纯右值可以通过`标准转换序列`转换到类型“指向 T1 的指针”, 那么 T1 `引用兼容`T2. 

## 初始化规则

如果引用初始化使用一般[或指派 (C++20 起)]`列表初始化`, 那么遵循列表初始化的规则. (C++11 起)

对于`非列表初始化`, 给定目标的类型为 U, 引用要么直接绑定到目标, 要么绑定到从目标转换到类型 T 的某个值. 先考虑`直接绑定`, 再考虑`间接绑定`, 如果没有绑定可用, 那么程序非良构. 

在所有情况下, 当两个类型的引用兼容关系被用于建立引用绑定的有效性时, 如果标准转换序列非良构, 那么需要建立该绑定的程序非良构. 

### 直接绑定

如果满足以下所有条件：

- 要初始化的引用是`左值引用`. 
- `目标`是`非位域`左值. 
- T `引用兼容` U. 

那么引用会绑定到`目标`或它合适的`基类子对象`：

```c++
double d = 2.0;
double& rd = d;        // rd 引用 d
const double& rcd = d; // rcd 引用 d
 
struct A {};
struct B : A {} b;
 
A& ra = b;             // ra 引用 b 中的 A 子对象
const A& rca = b;      // rca 引用 b 中的 A 子对象
```

否则, 如果满足以下所有条件：

- 要初始化的引用是`左值引用`. 
- U 是`类类型`. 
- T 不`引用关联`于 U. 
- `目标`可以转换成某个`类型 V`的`左值`, 并且T`引用兼容`V. 

那么引用会绑定到`转换结果左值`或它合适的`基类子对象`：

```c++
struct A {};
struct B : A { operator int&(); };
 
int& ir = B(); // ir 指代 B::operator int& 的结果
```

否则, 如果[要初始化的引用是`左值引用`, 并且 (C++11 起)] T `没有 const 限定`, 或者`具有 volatile 限定`, 那么程序非良构：

```c++
double& rd2 = 2.0; // 错误：不是左值, 并且引用不是 const 的
int i = 2;
double& rd3 = i;   // 错误：类型不匹配, 并且引用不是 const 的
```

否则, 如果满足以下所有条件：

- 目标是以下类别之一的值：
  - 右值 (C++11 前)
  - 非位域亡值
  - 类纯右值 (C++11 起)
  - 数组纯右值 (C++17 前)
  - 函数左值
  - 非位域右值(C++17 起)
  - 函数左值(C++17 起)

- T 引用兼容 U. 

那么引用会绑定到`目标`或它合适的`基类子对象`：
```c++
struct A {};
struct B : A {};
extern B f();
 
const A& rca2 = f(); // 到 B 右值的 A 子对象. 
A&& rra = f();       // 同上
 
int i2 = 42;
int&& rri = static_cast<int&&>(i2); // 直接绑定到 i2
```

如果目标是`纯右值`, 那么会对它应用`临时量实质化`. 引用会绑定到`结果对象`或它合适的`基类子对象`. (C++17 起)

否则, 如果满足以下所有条件：

U 是类类型. 
T 不引用关联与 U. 
目标可以转换成某个类型 V 的值 v, 并且 T 引用兼容 V, 其中 v 属于是以下类别之一：
右值
(C++11 前)
亡值
类纯右值
函数左值
(C++11 起)
(C++17 前)
右值
函数左值
(C++17 起)
那么引用会绑定到转换结果或它合适的基类子对象：

struct A {};
struct B : A {};
struct X { operator B(); } x;
 
const A& r = x; // 绑定到转换结果的 A 子对象
B&& rrb = x;    // 直接绑定到转换的结果
如果转换结果是纯右值, 那么

首先它的类型 C 会进行调整：将 T 的 cv 限定添加到 C. 
然后对结果应用临时量实质化. 
引用会绑定到结果对象或它合适的基类子对象. 

(C++17 起)

### 间接绑定
如果直接绑定不可用, 那么就会考虑间接绑定. 此时 T 不能引用关联于 U. 

如果 T 或 U 是类类型, 会以通过用户定义转换进行的对类型 T 对象进行复制初始化的规则考虑用户定义转换. 如果对应的非引用复制初始化非良构, 那么程序非良构. 转换函数调用的结果（在非引用复制初始化部分描述）会用于直接初始化引用, 此直接初始化不会再考虑用户定义转换. 

否则会从目标创建并复制初始化一个类型 T 的临时量. 引用会绑定到该临时量. 

(C++17 前)
否则目标会隐式转换成一个类型是“无 cv 限定的 T” 的纯右值. 然后应用临时量实质化, 在将该纯右值的类型视为 T 的情况下将引用绑定到结果对象. 

(C++17 起)
const std::string& rs = "abc"; // rs 指代从字符数组复制初始化的临时量
const double& rcd2 = 2;        // rcd2 指代值为 2.0 的临时量
int i3 = 2;
double&& rrd3 = i3;            // rrd3 指代值为 2.0 的临时量

## 临时量的生存期
一旦引用被绑定到临时对象或它的子对象, 临时对象的生存期就被延续以匹配引用的生存期（检查临时对象生存期的例外）, 其中临时对象或它的子对象由下列表达式之一代表：

对象类型的纯右值表达式,
(C++17 前)
临时量实质化转换,
(C++17 起)
有括号表达式 (e), 其中 e 是这些表达式之一,
形式为 a[n] 或 n[a] 的内建的下标表达式, 其中 a 是数组并且是这些表达式之一,
形式为 e.m 的成员访问表达式, 其中 e 是这些表达式之一且 m 指代对象类型的非静态数据成员,
形式为 e.*mp 的成员指针操作, 其中 e 是这些表达式之一且 mp 是指向数据成员的指针,
无用户定义转换的 const_cast,static_cast,dynamic_cast 或 reinterpret_cast 转换, 它将这些表达式之一转换成指代操作数所指代的对象, 它的完整对象, 或完整对象的子对象的泛左值（显式转型表达式被转译成这些基础转型的序列）,
形式为 cond ? e1 : e2 并且是泛左值的条件表达式, 其中 e1 或 e2 是这些表达式之一, 或
形式为 x, e 并且是泛左值的内建的逗号表达式, 其中 e 是这些表达式之一. 
此生存期规则有下列例外：

return 语句中绑定到函数返回值的临时量不会被延续：它在返回表达式的末尾立即销毁. 这种 return 语句始终返回悬垂引用. 
在函数调用中绑定到函数形参的临时量, 存在到含这次函数调用的全表达式结尾为止：如果函数返回一个生命长于全表达式的引用, 那么它会成为悬垂引用. 
绑定到 new 表达式中所用的初始化器中的引用的临时量, 存在到含有该 new 表达式的全表达式结尾为止, 而非被初始化对象的存在期间. 如果被初始化对象的生命长于全表达式, 那么它的引用成员将成为悬垂引用. 
(C++11 起)
绑定到用直接初始化语法（圆括号）, 而非列表初始化语法（花括号）初始化的聚合体的引用元素中的引用的临时量, 存在直至含该初始化器的全表达式末尾为止. 
struct A
{
    int&& r;
};
 
A a1{7}; // OK：延续生存期
A a2(7); // 良构, 但有悬垂引用
(C++20 起)
总而言之, 临时量的生存期不能以进一步“传递”来延续：从绑定了该临时量的引用或数据成员初始化的第二引用不影响临时量的生存期. 

注解
只有在函数形参声明中, 函数返回类型声明中, 类成员声明中, 以及带 extern 说明符时, 引用不需要与初始化器一同出现. 

在解决 CWG 问题 1696 前, 在构造函数的成员初始化器列表中可以绑定临时量到引用成员, 而临时量只持续到构造函数退出前, 而非对象存在期间. 这种初始化从 CWG 1696 开始非良构, 不过许多编译器仍然支持它（值得注意的例外是 clang）. 
