本文参考cppreference 上的`构造函数与成员初始化式列表`说明，整理如下内容：

https://zh.cppreference.com/w/cpp/language/constructor

# 简介
构造函数是类的一种特殊的非静态成员函数，用于初始化该类类型的对象。

在类的 构造函数定义中，成员初始化式列表 指定各个 直接基类、虚基类 和 非静态数据成员的 初始化式。（请勿与 std::initializer_list 混淆。）

构造函数不能是 协程。(C++20 起)

构造函数不能有 显式对象形参。(C++23 起)


# 语法
## 构造函数声明
构造函数 用以下形式的 成员函数声明符 声明：
类名 ( 形参列表 ﻿(可选) )  异常说明 ﻿(可选)  属性 ﻿(可选) (1)

其中 类名 必须指名当前类（或类模板的当前实例化），或当在命名空间作用域 或 在友元声明中声明时，它必须是有限定的类名。

构造函数声明的 声明说明符序列 中只允许说明符 friend、inline、constexpr (C++11 起)、consteval (C++20 起) 及 explicit（尤其是不允许返回类型）。注意 cv 及 引用限定符 也不受允许；const 与 volatile 语义对于构造过程中的对象没有效果，它们要到最终派生类的构造函数完成才会生效。

## 构造函数定义里的 成员初始化式列表
任何构造函数的 函数定义的 函数体，可以在 复合语句的 开花括号 之前包含 成员初始化式列表，其语法是 冒号字符 :  后随一个或多个 成员初始化式 的 逗号分隔列表，每项均具有以下语法：
类或标识符 ( 表达式列表 ﻿(可选) ) (1)
类或标识符 花括号初始化列表 (2) (C++11 起)
形参包 ... (3) (C++11 起)

1) 用直接初始化，或当 表达式列表 为空时用 值初始化，初始化 类或标识符 所指名的 基类或成员
2) 用列表初始化（列表为空时进行 值初始化，而在 初始化聚合体时 进行聚合初始化），初始化 类或标识符 所指名的 基类或成员
3) 用包展开初始化多个基类

类或标识符 - 任何指名 非静态数据成员的 标识符，或任何指名 该类自身（对于委托构造函数）、直接基类或虚基类的 类型名。
表达式列表 - 传递给 基类或成员的 实参的 逗号分隔列表，可以为空
花括号初始化列表 - 花括号包围的 以逗号分隔的 初始化式 和 嵌套的花括号初始化列表 的列表
形参包	-	变参模板形参包的名字
struct S{
    int n;
    S(int);       // 构造函数声明
    S() : n(7) {} // 构造函数定义：
                  // ": n(7)" 是初始化式列表
                  // ": n(7) {}" 是函数体
};
 
S::S(int x) : n{x} {} // 构造函数定义：": n{x}" 是初始化式列表
 
int main(){
    S s;      // 调用 S::S()
    S s2(10); // 调用 S::S(int)
}

# 例子

L19 有编译警告, 因成员无依赖, 不影响初始化.
L29 有编译警告, 因 成员x 用 成员y 做初始化, 按声明顺序 成员x 先初始化, 导致成员x的 值 不确定, 需成员y的 声明顺序 提到 成员x 前面.
#include "pch.h"
#include "CsFvLang.h"

void CsFvLang::ClassConstructorAndMembInitList() {
    at_mlog("====== ClassConstructorAndMembInitList 构造函数与成员初始化式列表 ======\n");
    struct Base {
        int n;
    };
    struct Class : public Base {
        unsigned char x;
        unsigned char y;
        std::mutex m;
        std::lock_guard< std::mutex > lg;
        std::fstream f;
        std::string s;

        Class(int x)
            : Base{ 123 },  // 初始化基类
              y(0),  // y 初始化为 0；编译警告: `initializer order` does not match the `declaration order`;
              x(x),  // x（成员）以 x（形参）初始化
              f{ "test.cc", std::ios::app },  // 在 m 和 lg 初始化之后发生
              s(__func__),  //__func__ 可用，因为初始化器列表是构造函数的一部分
              lg(m),  // lg 使用已经初始化的 m
              m{}  // m 在 lg 前初始化，即使它最后出现在此处
        {}  // 空复合语句

        Class(double a)
            : y(a + 1),
              x(y),  // x 将在 y 前初始化，它的值不确定；编译警告: field 'y' is uninitialized when used here
              lg(m) {
        }  // 基类初始化式未在列表中出现，它被默认初始化（这与使用 Base() 不同，那是值初始化）

        Class() try  // 函数 try 块在包含初始化式列表的函数体之前开始
            : Class(0.0)  // 委托构造函数
        {
            // ...
        }
        catch (...) {
            // 初始化中发生的异常
        }
    };
    Class c;
    at_mtrace("c.x:%d, c.y:%d\n", c.x, c.y);
    Class c1(1);
    at_mtrace("c1.x:%d, c1.y:%d\n", c1.x, c1.y);
    Class c2(0.1);
    at_mtrace("c2.x:%d, c2.y:%d\n", c2.x, c2.y);
}



## 输出
L43 : c.x:204, c.y:1
L45 : c1.x:1, c1.y:0
L47 : c2.x:204, c2.y:1

# 解释
构造函数 没有名字 且无法被直接调用。它们在 发生初始化时 被调用，且它们按照 初始化的规则 进行选择。没有 explicit 说明符的 构造函数是转换构造函数。有 constexpr 说明符的 构造函数会让 其类型 成为字面类型。可以不带任何实参调用的 构造函数 是默认构造函数。可以接收同类型的 另一对象为实参的 构造函数是 复制构造函数 和 移动构造函数。



在开始执行 组成构造函数体的 复合语句之前，所有 直接基类、虚基类 和 非静态数据成员的 初始化 均已结束。

这些对象的 非默认初始化 只能在 成员初始化式列表 指定。对于不能默认初始化的 基类，和不能以默认初始化 `或 以其默认成员初始化式（如果有）(C++11 起)` 初始化的 非静态数据成员，例如 引用 和 const限定的类型的成员，必须指定 成员初始化式。`（注意，类模板实例化的 非静态数据成员的 默认成员初始化式，当成员类型 或初始化式待决时 可能是无效的。) (C++11 起)` 对没有 成员初始化式 `或默认成员初始化式 (C++11 起)` 的 匿名联合体 或 变体成员 不进行初始化。



类或标识符 指名 虚基类的 初始化式，在并非所构造对象的 最终派生类的类的 构造期间被忽略。

在 表达式列表 或 花括号初始化列表 中出现的名字在构造函数的作用域中求值：

class X {
    int a, b, i, j;
  public:
    const int& r;
    X(int i)
      : r(a) // 初始化 X::r 以指代 X::a
      , b{i} // 初始化 X::b 为形参 i 的值
      , i(i) // 初始化 X::i 为形参 i 的值
      , j(this->i) // 初始化 X::j 为 X::i 的值
    {}
};
成员初始化式 所抛出的 异常 可以被 函数 try 块 处理。

成员函数（包括虚成员函数）可以从 成员初始化式 调用，但如果在该点 还有直接基类 尚未被初始化，那么行为未定义。

对于虚调用（如果在该点已初始化直接基类），适用与 从构造函数 与析构函数中 进行虚函数调用相同的规则：虚成员函数 表现如同 *this 的 动态类型 是正在构造的类的 静态类型（动态派发不会沿继承层级下传），而对 纯虚成员函数的 虚调用（而非静态调用）是未定义行为。



如果非静态数据成员 具有 默认成员初始化式 且也在 成员初始化式列表 出现，那么使用 该 成员初始化式 而忽略 默认成员初始化式：(C++11 起)

struct S {
    int n = 42;   // 默认成员初始化式
    S() : n(7) {} // 将设置 n 为 7，而非 42
};


引用成员 不能绑定到 成员初始化式列表 的 临时量：

struct A {
    A() : v(42) {} // 错误
    const int& v;
};
注：这同样适用于 默认成员初始化式。

## 委托构造函数
如果类自身的 名字 在初始化式列表中 作为 类或标识符 出现，那么该列表 只能由这 一个成员初始化式 组成；这种构造函数 被称为 委托构造函数（delegating constructor），而构造函数列表的 仅有成员 所选择的 构造函数是 目标构造函数。

此时首先由 重载决议 选择 目标构造函数 并予以执行，然后控制返回到 委托构造函数 并执行其函数体。

委托构造函数 不能递归。

class Foo {
public: 
    Foo(char x, int y) {}
    Foo(int y) : Foo('a', y) {} // Foo(int) 委托到 Foo(char, int)
};

## 继承的构造函数
见 using 声明。(C++11 起)

## 初始化顺序
列表中的 成员初始化式的 顺序 无关紧要：初始化的实际顺序如下：

1) 如果构造函数是 最终派生类的，那么按 基类声明的 深度优先、从左到右的 遍历中的 出现顺序（从左到右指的是 基说明符列表中 所呈现的顺序），初始化各个虚基类
2) 然后，以在此类的 基类说明符列表中 出现的 从左到右顺序，初始化各个 直接基类
3) 然后，以类定义中的 声明顺序，初始化各个 非静态成员。
4) 最后，执行 构造函数体

（注意：如果初始化的顺序是 由不同构造函数中的 成员初始化式列表中 的出现 所控制，那么析构函数 就无法确保销毁顺序是 构造顺序的逆序了。）
