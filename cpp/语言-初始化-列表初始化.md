本文参考`列表初始化`文档整理.
https://zh.cppreference.com/w/cpp/language/list_initialization

## 概述:

列表初始化, 是从`花括号初始化列表`执行初始化.

我的总结:

- 可表现为`聚合初始化` [参考 #xg1](#xg1), [参考 #xg3](#xg3)
- 可表现为`复制初始化`或`直接初始化` [参考 #xg2](#xg2)
- 可表现为`值初始化` [参考 #xg4](#xg4)

## 语法

**直接列表初始化**

- `T 对象 { 实参1, 实参2, ... };` `T 对象{.指派符1 = 实参1 , .指派符2 { 实参2 } ... }; (C++20 起)` (1)
- `T { 实参1, 实参2, ... }` `T {.指派符1 = 实参1 , .指派符2 { 实参2 } ... } (C++20 起)` (2)
- `new T { 实参1, 实参2, ... }` `new T {.指派符1 = 实参1 , .指派符2 { 实参2 } ... } (C++20 起)` (3)
- `类 { T 成员 { 实参1, 实参2, ... }; };` `类 { T 成员 {.指派符1 = 实参1 , .指派符2 { 实参2 } ... }; }; (C+`+20 起)` (4)
- `类::类() : 成员 { 实参1, 实参2, ... } {...` `类::类() : 成员 {.指派符1 = 实参1 , .指派符2 { 实参2 } ...} {... (C++20 起)` (5)

**复制列表初始化**

- `T 对象 = { 实参1, 实参2, ... };` `T 对象 = {.指派符1 = 实参1 , .指派符2 { 实参2 } ... }; (C++20 起)` (6)
- `函数 ({ 实参1, 实参2, ... })` `函数 ({.指派符1 = 实参1 , .指派符2 { 实参2 } ... }) (C++20 起)` (7)
- `return { 实参1, 实参2, ... };` `return {.指派符1 = 实参1 , .指派符2 { 实参2 } ... }; (C++20 起)` (8)
- `对象 [{ 实参1, 实参2, ... }]` `对象 [{.指派符1 = 实参1 , .指派符2 { 实参2 } ... }] (C++20 起)` (9)
- `对象 = { 实参1, 实参2, ... }` `对象 = {.指派符1 = 实参1 , .指派符2 { 实参2 } ... } (C++20 起)` (10)
- `U ({ 实参1, 实参2, ... })` `U ({.指派符1 = 实参1 , .指派符2 { 实参2 } ... }) (C++20 起)` (11)
- `类 { T 成员 = { 实参1, 实参2, ... }; };` `类 { T 成员 = {.指派符1 = 实参1 , .指派符2 { 实参2 } ... }; }; (C++20 起)` (12)

语法解释:

**直接列表初始化**（考虑`explicit`和`非 explicit`构造函数）

1. 以`花括号初始化列表`（即`花括号环绕的可以为空的表达式`或`花括号初始化列表`的`列表`）初始化`具名变量`
2. 以`花括号初始化列表`初始化`无名临时量`
3. 以`new 表达式`初始化具有`动态存储期`的对象, 它的`初始化器`是`花括号初始化列表`
4. 在不使用`等号`的非静态数据`成员初始化器`中
5. 在构造函数的`成员初始化列表`中, 如果使用`花括号初始化列表`

**复制列表初始化**（考虑`explicit`和`非 explicit`构造函数, 但只能调用`非 explicit`构造函数）

6. 以`等号`后的`花括号初始化列表`初始化具名变量
7. 函数调用表达式中, 以`花括号初始化列表`作为实参, 以`列表初始化`对`函数形参`初始化
8. 在以`花括号初始化列表`作为`返回表达式`的`return`语句中, 以`列表初始化`对`返回的对象`初始化
9. 在具有`用户定义`的`operator[]`的下标表达式中, 以`列表初始化`对`重载运算符`的`形参`初始化
10. 在`赋值表达式`中, 以`列表初始化`对`重载运算符`的`形参`初始化
11. `函数式转型`表达式或其他`构造函数`调用, 其中`花括号初始化列表`用作构造函数实参. 以`复制初始化`对构造函数的`形参`初始化（注意: 此例中的`类型 U`不是被`列表初始化`的类型；但`U`的构造函数的`形参`是）
12. 在使用`等号`的非静态数据`成员初始化器`中

### T 类型的对象的`列表初始化`的效果是:

- [<b name="xg1">#xg1</b>] 如果`花括号初始化列表`包含`指派`初始化器列表, 并且 T 不是`引用`类型, 那么 T 必须是`聚合类`. 由`指派`初始化器列表中的`指派符`组成的标识符序列必须是 T 的非静态`数据`成员组成的`标识符`序列的`子序列`. 进行`聚合`初始化. (C++20 起)
- [<b name="xg2">#xg2</b>] 如果 T 是`聚合类`且`花括号初始化列表`[在不含`指派`初始化器列表的情况下 (C++20 起)]拥有`单个`（可有 cv 限定的）相同类型或派生类型的元素, 那么从该元素初始化对象（对于`复制列表初始化`为复制初始化, 对于`直接列表初始化为`直接初始化）.
- 否则, 如果 T 是`字符数组`且初始化列表拥有`单个`类型适当的`字符串字面量`元素, 那么照常从`字符串字面量`初始化数组.
- [<b name="xg3">#xg3</b>] 否则, 如果 T 是`聚合类型`, 那么进行`聚合`初始化.
- [<b name="xg4">#xg4</b>] 否则, 如果`花括号初始化列表`列表为空, 且 T 是拥有`默认构造函数`的`类类型`, 那么进行`值初始化`.
- 否则, 如果 T 是`std::initializer_list`的`特化`, 那么该 T 对象会以[列表初始化 std::initializer_list](#列表初始化`std::initializer_list`)初始化.

- 否则, 以两个阶段考虑 T 的`构造函数`:

  - 检验所有接受`std::initializer_list`作为它的`唯一实参`, 或如果`剩余实参`都具有`默认值`则为它的首个实参的构造函数, 并通过重载决议与`单个std::initializer_list`类型的实参进行匹配.
  - 如果上一个阶段未产生匹配, 那么 T 的所有`构造函数`都参与针对由`花括号初始化列表`的`各元素`所组成的实参集的重载决议, 它会受到只允许`非窄化`转换的限制. 如果这个阶段为`复制列表初始化`产生的最佳匹配是`explicit`构造函数, 那么编译失败（注意: 简单`复制初始化`中完全不考虑`explicit`构造函数）.

- 否则, 如果 T 是拥有`固定底层类型 U`的`枚举类型`, `花括号初始化列表`只有一个初始化器`v`, 并且满足以下所有条件, 那么就会以将`v`转换到`U`的结果初始化该枚举: (C++17 起)

  - 初始化是`直接列表初始化`.
  - v 具有`标量类型`.
  - v 可`隐式转换`到 U.
  - 从 v 到 U 的转换不是`窄化`转换.

- 否则（如果 T `不是类类型`）, 如果`花括号初始化列表`只有`一个元素`, 且 T 要么不是引用类型, 要么是引用类型而它所引用的类型与该元素的类型相同或者是它的基类, 那么`直接初始化`（直接列表初始化时）或`复制初始化`（复制列表初始化时）这个 T, 但`不允许窄化`转换.

- 否则, 如果 T 是`引用`类型, 那么:

  - (C++17 前) `复制列表初始化`一个具有由 T 引用的类型的`纯右值`临时量, 并且将引用绑定到该`临时量`（如果引用是`非 const 左值引用`则失败）.
  - (C++17 起) 生成一个`纯右值`. 该纯右值以`复制列表初始化`来初始化它的`结果对象`. 然后用该纯右值`直接初始化`引用（如果引用是`非 const 左值引用`则失败）. 该临时量的类型是由 T 引用的类型 [, 除非 T 是“到 U 的未知边界的数组的引用”, 此时该临时量的类型是声明 U x[] H 中 x 的类型, 其中 H 是对应的初始化列表 (C++20 起)].

- 否则, 如果`花括号初始化列表`没有任何元素, 那么`值初始化` T.

## 列表初始化`std::initializer_list`

类型是 std::initializer_list<E> 的对象从初始化器列表构造时，编译器如同生成并实质化 (C++17 起)一个类型是“包含 N 个 const E 元素的数组”的纯右值，其中 N 是初始化器列表中的元素个数；该数组被称为该初始化器列表的基底数组。

基底数组中的每个元素都会以初始化器列表中的对应元素复制初始化，并且构造的 std::initializer_list<E> 的对象会指代基底数组。复制操作选择的构造函数或转换函数必须在初始化器列表的语境下可访问。如果初始化元素时需要进行窄化转换，那么程序非良构。

基底数组的生存期与其他临时对象基本一样，但区别在从基底数组初始化 std::initializer_list 对象时会与绑定引用到临时量一样延续基底数组的生存期。

void f(std::initializer_list<double> il);

void g(float x)
{
f({1, x, 3});
}

void h()
{
f({1, 2, 3});
}

struct A { mutable int i; };

void q(std::initializer_list<A>);

void r()
{
q({A{1}, A{2}, A{3}});
}

// 以上初始化会以大致与以下相同的方式实现，前提是编译器可以以一对指针构造
// initializer_list 对象，并且 \_\_b 的生存期不会持续到 f 的调用以外。

void g(float x)
{
const double **a[3] = {double{1}, double{x}, double{3}}; // 基底数组
f(std::initializer_list<double>(**a, \_\_a + 3));
}

void h()
{
static constexpr double **b[3] =
{double{1}, double{2}, double{3}}; // 基底数组
f(std::initializer_list<double>(**b, \_\_b + 3));
}

void r()
{
const A **c[3] = {A{1}, A{2}, A{3}}; // 基底数组
q(std::initializer_list<A>(**c, \_\_c + 3));
}
未指定基底数组是否各异（即它们各自在不重叠的对象中存储）：

bool fun(std::initializer_list<int> il1, std::initializer_list<int> il2)
{
return il2.begin() == il1.begin() + 1;
}

bool overlapping = fun({1, 2, 3}, {2, 3, 4}); // 结果未指定：两个基底数组可以
// 在 {1, 2, 3, 4} 上共享存储
