本文参考`列表初始化`文档整理.
https://zh.cppreference.com/w/cpp/language/list_initialization

## 概述:

列表初始化, 是从`花括号初始化列表`执行初始化.

我的总结:

- 可表现为`值初始化` [参考 #xg4](#xg4)
- 可表现为`聚合初始化` [参考 #xg1](#xg1), [参考 #xg3](#xg3)
- 可表现为`复制初始化`或`直接初始化` [参考 #xg2](#xg2)

## 语法

**直接列表初始化**

- `T 对象 { 实参1, 实参2, ... };` `T 对象{.指派符1 = 实参1 , .指派符2 { 实参2 } ... }; (C++20 起)` (1)
- `T { 实参1, 实参2, ... }` `T {.指派符1 = 实参1 , .指派符2 { 实参2 } ... } (C++20 起)` (2)
- `new T { 实参1, 实参2, ... }` `new T {.指派符1 = 实参1 , .指派符2 { 实参2 } ... } (C++20 起)` (3)
- `类 { T 成员 { 实参1, 实参2, ... }; };` `类 { T 成员 {.指派符1 = 实参1 , .指派符2 { 实参2 } ... }; }; (C+`+20 起)` (4)
- `类::类() : 成员 { 实参1, 实参2, ... } {...` `类::类() : 成员 {.指派符1 = 实参1 , .指派符2 { 实参2 } ...} {... (C++20 起)` (5)

**复制列表初始化**

- `T 对象 = { 实参1, 实参2, ... };` `T 对象 = {.指派符1 = 实参1 , .指派符2 { 实参2 } ... }; (C++20 起)` (6)
- `函数 ({ 实参1, 实参2, ... })` `函数 ({.指派符1 = 实参1 , .指派符2 { 实参2 } ... }) (C++20 起)` (7)
- `return { 实参1, 实参2, ... };` `return {.指派符1 = 实参1 , .指派符2 { 实参2 } ... }; (C++20 起)` (8)
- `对象 [{ 实参1, 实参2, ... }]` `对象 [{.指派符1 = 实参1 , .指派符2 { 实参2 } ... }] (C++20 起)` (9)
- `对象 = { 实参1, 实参2, ... }` `对象 = {.指派符1 = 实参1 , .指派符2 { 实参2 } ... } (C++20 起)` (10)
- `U ({ 实参1, 实参2, ... })` `U ({.指派符1 = 实参1 , .指派符2 { 实参2 } ... }) (C++20 起)` (11)
- `类 { T 成员 = { 实参1, 实参2, ... }; };` `类 { T 成员 = {.指派符1 = 实参1 , .指派符2 { 实参2 } ... }; }; (C++20 起)` (12)

语法解释:

**直接列表初始化**（考虑 explicit 和非 explicit 构造函数）

1. 以`花括号初始化列表`（即`花括号环绕的可以为空的表达式`或`花括号初始化列表`的`列表`）初始化`具名变量`
2. 以`花括号初始化列表`初始化`无名临时量`
3. 以`new 表达式`初始化具有`动态存储期`的对象, 它的`初始化器`是`花括号初始化列表`
4. 在不使用等号的非静态数据`成员初始化器`中
5. 在构造函数的`成员初始化列表`中, 如果使用`花括号初始化列表`

**复制列表初始化**（考虑 explicit 和非 explicit 构造函数, 但只能调用非 explicit 构造函数）

6. 以`等号后`的`花括号初始化列表`初始化具名变量
7. 函数调用表达式中, 以`花括号初始化列表`作为实参, 以列表初始化对函数形参初始化
8. 在以`花括号初始化列表`作为返回表达式的 return 语句中, 以列表初始化对返回的对象初始化
9. 在具有用户定义的 operator[] 的下标表达式中, 以列表初始化对重载运算符的形参初始化
10. 在`赋值表达式`中, 以`列表初始化`对重载的运算符的形参初始化
11. 函数式`转型`表达式或其他`构造`函数调用, 其中`花括号初始化列表`用作构造函数实参. 以`复制`初始化对构造函数的形参初始化（注意: 此例中的类型 U 不是被列表初始化的类型；但 U 的构造函数的形参是）
12. 在使用等号的非静态数据`成员初始化器`中

### T 类型的对象的`列表初始化`的效果是:

- [<b name="xg1">#xg1</b>] 如果`花括号初始化列表`包含`指派`初始化器列表, 并且 T 不是`引用`类型, 那么 T 必须是`聚合类`. 由`指派`初始化器列表中的`指派符`组成的标识符序列必须是 T 的非静态`数据`成员组成的`标识符`序列的`子序列`. 进行`聚合`初始化. (C++20 起) 例如:语法`1,6`的含`指派符`的语句
- [<b name="xg2">#xg2</b>] 如果 T 是`聚合类`且`花括号初始化列表`[在不含`指派`初始化器列表的情况下 (C++20 起)]拥有`单个`（可有 cv 限定的）相同类型或派生类型的元素, 那么从该元素初始化对象（对于`复制`列表初始化为`复制`初始化, 对于`直接`列表初始化为`直接`初始化）.
- 否则, 如果 T 是`字符数组`且初始化列表拥有`单个`类型适当的`字符串字面量`元素, 那么照常从`字符串字面量`初始化数组.
- [<b name="xg3">#xg3</b>] 否则, 如果 T 是`聚合`类型, 那么进行`聚合`初始化.
- [<b name="xg4">#xg4</b>] 否则, 如果`花括号初始化列表`列表为空, 且 T 是拥有`默认构造函数`的`类类型`, 那么进行`值`初始化.
- 否则, 如果 T 是`std::initializer_list`的`特化`, 那么该 T 对象会以[列表初始化 std::initializer_list](#列表初始化`std::initializer_list`)初始化.
- 否则, 以两个阶段考虑 T 的`构造`函数:

  - 检验所有接受`std::initializer_list`作为它的唯一实参, 或如果剩余实参都具有`默认值`则为它的首个实参的构造函数, 并通过重载决议与`单个std::initializer_list`类型的实参进行匹配.
  - 如果上一个阶段未产生匹配, 那么 T 的所有`构造`函数都参与针对由`花括号初始化列表`的`各元素`所组成的实参集的重载决议, 它会受到只允许`非窄化`转换的限制. 如果这个阶段为`复制`列表初始化产生的最佳匹配是`explicit`构造函数, 那么编译失败（注意: 简单`复制`初始化中完全不考虑`explicit`构造函数）.

- 否则, 如果 T 是拥有固定底层类型 U 的枚举类型, `花括号初始化列表`只有一个初始化器 v, 并且满足以下所有条件, 那么就会以将 v 转换到 U 的结果初始化该枚举: (C++17 起)

  - 初始化是直接列表初始化.
  - v 具有标量类型.
  - v 可隐式转换到 U.
  - 从 v 到 U 的转换不是窄化转换.

- 否则（如果 T 不是类类型）, 如果`花括号初始化列表`只有一个元素, 且 T 要么不是引用类型, 要么是引用类型而它所引用的类型与该元素的类型相同或者是它的基类, 那么直接初始化（直接列表初始化时）或复制初始化（复制列表初始化时）这个 T, 但不允许窄化转换.
- 否则, 如果 T 是引用类型, 那么:

  - 复制列表初始化一个具有由 T 引用的类型的纯右值临时量, 并且将引用绑定到该临时量（如果引用是非 const 左值引用则失败）.(C++17 前)
  - 生成一个纯右值. 该纯右值以复制列表初始化来初始化它的结果对象. 然后用该纯右值直接初始化引用（如果引用是非 const 左值引用则失败）. 该临时量的类型是由 T 引用的类型, 除非 T 是“到 U 的未知边界的数组的引用”, 此时该临时量的类型是声明 U x[] H 中 x 的类型, 其中 H 是对应的初始化列表 (C++20 起).(C++17 起)

- 否则, 如果`花括号初始化列表`没有任何元素, 那么值初始化 T.

## 列表初始化`std::initializer_list`

类型是 std::initializer_list<E> 的对象从初始化器列表构造时，编译器如同生成并实质化 (C++17 起)一个类型是“包含 N 个 const E 元素的数组”的纯右值，其中 N 是初始化器列表中的元素个数；该数组被称为该初始化器列表的基底数组。

基底数组中的每个元素都会以初始化器列表中的对应元素复制初始化，并且构造的 std::initializer_list<E> 的对象会指代基底数组。复制操作选择的构造函数或转换函数必须在初始化器列表的语境下可访问。如果初始化元素时需要进行窄化转换，那么程序非良构。

基底数组的生存期与其他临时对象基本一样，但区别在从基底数组初始化 std::initializer_list 对象时会与绑定引用到临时量一样延续基底数组的生存期。

void f(std::initializer_list<double> il);

void g(float x)
{
f({1, x, 3});
}

void h()
{
f({1, 2, 3});
}

struct A { mutable int i; };

void q(std::initializer_list<A>);

void r()
{
q({A{1}, A{2}, A{3}});
}

// 以上初始化会以大致与以下相同的方式实现，前提是编译器可以以一对指针构造
// initializer_list 对象，并且 \_\_b 的生存期不会持续到 f 的调用以外。

void g(float x)
{
const double **a[3] = {double{1}, double{x}, double{3}}; // 基底数组
f(std::initializer_list<double>(**a, \_\_a + 3));
}

void h()
{
static constexpr double **b[3] =
{double{1}, double{2}, double{3}}; // 基底数组
f(std::initializer_list<double>(**b, \_\_b + 3));
}

void r()
{
const A **c[3] = {A{1}, A{2}, A{3}}; // 基底数组
q(std::initializer_list<A>(**c, \_\_c + 3));
}
未指定基底数组是否各异（即它们各自在不重叠的对象中存储）：

bool fun(std::initializer_list<int> il1, std::initializer_list<int> il2)
{
return il2.begin() == il1.begin() + 1;
}

bool overlapping = fun({1, 2, 3}, {2, 3, 4}); // 结果未指定：两个基底数组可以
// 在 {1, 2, 3, 4} 上共享存储
