本文参考`列表初始化`文档整理.
https://zh.cppreference.com/w/cpp/language/list_initialization

## 概述：

列表初始化, 是从`花括号初始化列表`执行初始化.

我的总结:

## 语法

**直接列表初始化**

- `T 对象 { 实参1, 实参2, ... };` `T 对象{.指派符1 = 实参1 , .指派符2 { 实参2 } ... };(C++20 起)` (1)
- `T { 实参1, 实参2, ... }` `T {.指派符1 = 实参1 , .指派符2 { 实参2 } ... } (C++20 起)` (2)
- `new T { 实参1, 实参2, ... }` `new T {.指派符1 = 实参1 , .指派符2 { 实参2 } ... } (C++20 起)` (3)
- `类 { T 成员 { 实参1, 实参2, ... }; };` `类 { T 成员 {.指派符1 = 实参1 , .指派符2 { 实参2 } ... }; }; (C++20 起)` (4)
- `类::类() : 成员 { 实参1, 实参2, ... } {...` `类::类() : 成员 {.指派符1 = 实参1 , .指派符2 { 实参2 } ...} {... (C++20 起)` (5)

**复制列表初始化**

- `T 对象 = { 实参1, 实参2, ... };` `T 对象 = {.指派符1 = 实参1 , .指派符2 { 实参2 } ... }; (C++20 起)` (6)
- `函数 ({ 实参1, 实参2, ... })` `函数 ({.指派符1 = 实参1 , .指派符2 { 实参2 } ... }) (C++20 起)` (7)
- `return { 实参1, 实参2, ... };` `return {.指派符1 = 实参1 , .指派符2 { 实参2 } ... }; (C++20 起)` (8)
- `对象 [{ 实参1, 实参2, ... }]` `对象 [{.指派符1 = 实参1 , .指派符2 { 实参2 } ... }] (C++20 起)` (9)
- `对象 = { 实参1, 实参2, ... }` `对象 = {.指派符1 = 实参1 , .指派符2 { 实参2 } ... } (C++20 起)` (10)
- `U ({ 实参1, 实参2, ... })` `U ({.指派符1 = 实参1 , .指派符2 { 实参2 } ... }) (C++20 起)` (11)
- `类 { T 成员 = { 实参1, 实参2, ... }; };` `类 { T 成员 = {.指派符1 = 实参1 , .指派符2 { 实参2 } ... }; }; (C++20 起)` (12)

语法解释：

**直接列表初始化**（考虑 explicit 和非 explicit 构造函数）

1. 以`花括号初始化列表`（即`花括号环绕的可以为空的表达式`或`花括号初始化列表`的`列表`）初始化`具名变量`
2. 以`花括号初始化列表`初始化`无名临时量`
3. 以`new 表达式`初始化具有`动态存储期`的对象, 它的`初始化器`是`花括号初始化列表`
4. 在不使用等号的非静态数据`成员初始化器`中
5. 在构造函数的`成员初始化列表`中, 如果使用花括号初始化列表

**复制列表初始化**（考虑 explicit 和非 explicit 构造函数, 但只能调用非 explicit 构造函数）

6. 以`等号后`的`花括号初始化列表`初始化具名变量
7. 函数调用表达式中, 以花括号初始化列表作为实参, 以列表初始化对函数形参初始化
8. 在以花括号初始化列表作为返回表达式的 return 语句中, 以列表初始化对返回的对象初始化
9. 在具有用户定义的 operator[] 的下标表达式中, 以列表初始化对重载运算符的形参初始化
10. 在`赋值表达式`中, 以`列表初始化`对重载的运算符的形参初始化
11. 函数式转型表达式或其他构造函数调用, 其中花括号初始化列表用作构造函数实参. 以复制初始化对构造函数的形参初始化（注意：此例中的类型 U 不是被列表初始化的类型；但 U 的构造函数的形参是）
12. 在使用等号的非静态数据`成员初始化器`中

解释

T 类型的对象的列表初始化的效果是：

如果花括号初始化列表包含指派初始化器列表, 并且 T 不是引用类型, 那么 T 必须是聚合类. 由指派初始化器列表中的指派符组成的标识符序列必须是 T 的非静态数据成员组成的标识符序列的子序列. 进行聚合初始化.
(C++20 起)
如果 T 是聚合类且花括号初始化列表在不含指派初始化器列表的情况下 (C++20 起)拥有单个（可有 cv 限定的）相同类型或派生类型的元素, 那么从该元素初始化对象（对于复制列表初始化为复制初始化, 对于直接列表初始化为直接初始化）.
否则, 如果 T 是字符数组且初始化列表拥有单个类型适当的字符串字面量元素, 那么照常从字符串字面量初始化数组.
否则, 如果 T 是聚合类型, 那么进行聚合初始化.
否则, 如果花括号初始化列表列表为空, 且 T 是拥有默认构造函数的类类型, 那么进行值初始化.
否则, 如果 T 是 std::initializer_list 的特化, 那么该 T 对象会以如下方式初始化.
否则, 以两个阶段考虑 T 的构造函数：
检验所有接受 std::initializer_list 作为它的唯一实参, 或如果剩余实参都具有默认值则为它的首个实参的构造函数, 并通过重载决议与单个 std::initializer_list 类型的实参进行匹配.
如果上一个阶段未产生匹配, 那么 T 的所有构造函数都参与针对由花括号初始化列表的各元素所组成的实参集的重载决议, 它会受到只允许非窄化转换的限制. 如果这个阶段为复制列表初始化产生的最佳匹配是 explicit 构造函数, 那么编译失败（注意：简单复制初始化中完全不考虑 explicit 构造函数）.
否则, 如果 T 是拥有固定底层类型 U 的枚举类型, 花括号初始化列表只有一个初始化器 v, 并且满足以下所有条件, 那么就会以将 v 转换到 U 的结果初始化该枚举：
初始化是直接列表初始化.
v 具有标量类型.
v 可隐式转换到 U.
从 v 到 U 的转换不是窄化转换.
(C++17 起)
否则（如果 T 不是类类型）, 如果花括号初始化列表只有一个元素, 且 T 要么不是引用类型, 要么是引用类型而它所引用的类型与该元素的类型相同或者是它的基类, 那么直接初始化（直接列表初始化时）或复制初始化（复制列表初始化时）这个 T, 但不允许窄化转换.
否则, 如果 T 是引用类型, 那么：
复制列表初始化一个具有由 T 引用的类型的纯右值临时量, 并且将引用绑定到该临时量（如果引用是非 const 左值引用则失败）.
(C++17 前)
生成一个纯右值. 该纯右值以复制列表初始化来初始化它的结果对象. 然后用该纯右值直接初始化引用（如果引用是非 const 左值引用则失败）. 该临时量的类型是由 T 引用的类型, 除非 T 是“到 U 的未知边界的数组的引用”, 此时该临时量的类型是声明 U x[] H 中 x 的类型, 其中 H 是对应的初始化列表 (C++20 起).
(C++17 起)
否则, 如果花括号初始化列表没有任何元素, 那么值初始化 T.
