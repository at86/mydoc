本文参考`值初始化`文档整理.
https://zh.cppreference.com/w/cpp/language/value_initialization

## 概述：

这是在以`空初始化器`构造对象时进行的初始化.

我的总结:

- `值初始化`, 要么是`零初始化`, 要么是`默认初始化`.
- 对于`类类型`, 必须有`默认构造函数`
- 标量类型, POD 类类型, 执行`零值初始化`
- 只有`编译器生成`的`默认构造函数`, 执行`零值初始化`
- 只有`用户定义`的`默认构造函数`, 执行`默认初始化`
- 同时有以上两种`默认构造函数`, 编译失败, 报`包含多个默认构造函数, 对重载函数的调用不明确`

## 语法

- `T ()` (1)
- `new T ()` (2)
- `类::类(...) : 成员() { ... }` (3)
- `T 对象 {};` (4) (C++11 起)
- `T {}` (5) (C++11 起)
- `new T {}` (6) (C++11 起)
- `类::类(...) : 成员{} { ... }` (7) (C++11 起)

语法解释：

- 1,5) 当以空的括号或花括号 (C++11 起)对组成的初始化器创建无名临时对象时；
- 2,6) 当 new 表达式以空的括号或花括号 (C++11 起)对组成的初始化器创建具有动态存储期的对象时；
- 3,7) 当使用以空的括号或花括号 (C++11 起)对组成的成员初始化器初始化非静态数据成员或基类时；
- 4. 当以由空花括号对组成的初始化器声明具名对象（自动、静态或线程局部）时. (C++11 起)

所有情况下, 如果使用`空花括号对 {}`且`T 是聚合类型`, 那么进行`聚合初始化`而非值初始化. 如:`int* a = new int[10](); // 数组=>每个元素的值初始化 每个元素的值为 0`

如果 T 是没有默认构造函数但带有接受 std::initializer_list 的构造函数的类类型, 那么进行列表初始化. (C++11 起)

### 值初始化的效果是：

1. 如果 T 是没有`默认构造函数`, 或拥有[[由用户声明的 (C++11 前)][由用户提供的或被删除的 (C++11 起)]]默认构造函数的`类类型`, 那么对象被`默认初始化`；
2. 如果 T 是拥有`默认构造函数`的`类类型`, 而默认构造函数[不由用户声明 (C++11 前)][既不由用户提供也没有被删除 (C++11 起)]（即它可以是拥有`隐式定义`的或`默认化`的默认构造函数的类）, 那么`零初始化对象`, 然后如果它拥有非平凡的`默认构造函数`, 那么就会`默认初始化`它；
3. 如果 T 是数组类型, 那么`值初始化`数组的每个元素；
4. 否则, `零初始化`对象.

## 注解

语法`T object();`不初始化对象；它`声明`一个不接受参数并返回 T 的`函数`. 在 C++11 前`值初始化`一个具名变量的方式是 `T object = T();`, 它值初始化一个临时量然后复制初始化该对象：多数编译器在此情况下能优化掉复制.

在 C++03（引入了值初始化）之前的 C++98 中, 表达式 `new T()` 被归类为默认初始化并指定进行零初始化.

引用不能被值初始化.

如函数式转型中所述, 数组禁止语法 `T()` (1) , 但允许 `T{}` (5).

所有标准容器（std::vector、std::list 等）在以单个 size_type 实参进行构造或由对 resize() 的调用而增长时`值初始化`它们的各个元素, 除非它们的分配器定制 construct 的行为.

从 C++11 起, 对`没有用户提供的构造函数`而`拥有类类型成员的类`进行`值初始化`, 其中成员的类拥有用户提供的构造函数, 会在调用成员的构造函数前对成员清零.

标准指定在`类拥有用户提供的默认构造函数时`或`被删除的默认构造函数时`不进行`零初始化`, 即使重载决议不选择该默认构造函数. 所有已知编译器都在选择未被删除的默认化的默认构造函数时进行额外的零初始化.
