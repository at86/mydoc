本文参考`复制初始化`文档整理.
https://zh.cppreference.com/w/cpp/language/copy_initialization

## 概述：

从`另一个对象`初始化对象.

通过`文档阅读`和`代码调试`后结论:

- 类类型的`复制初始化`, 需要类的:`复制构造函数`或`移动构造函数`或`转换构造函数`或`转换函数`等`非显式`版本

## 语法

- `T 对象 = 其他对象;` (1)
- `T 对象 = {其他对象};` (2) (C++11 前)
- `f(其他对象)` (3)
- `return 其他对象;` (4)
- `throw 对象;` `catch (T 对象)` (5)
- `T 数组[N] = {其他序列};` (6)

语法解释：

1. 当`非引用类型 T`的具名变量（自动、静态或线程局部）, 声明时带有以`等号后随一个表达式`所构成的初始化式时.
2. (C++11 前)当`标量类型 T`的具名变量, 声明时带有以等号后随一个花括号环绕的表达式所构成的初始化式时（注意：从 C++11 开始, 这被归类为`列表初始化`, 且不允许`窄化转换`）.
3. 当`按值传递实参`到函数时.
4. 当从`按值返回`的函数中返回时.
5. 当`按值抛出异常`或`按值捕获异常`时.
6. 作为`聚合初始化`的`一部分`, 用以初始化`每个提供了初始化式`的元素, 并`值初始化`任何`无初始化式的元素`.

复制初始化的效果是：

- 首先, 如果 T 是类类型, 且初始化式是纯右值表达式, 而它的无 cv 限定的类型是与 T 相同的类, 那么以初始化式表达式自身（而非从它所实质化的临时量）初始化目标对象：见复制消除. (C++17 起)
- 否则, 如果 T 是类类型, 且 其他对象 的类型的无 cv 限定版本是 T 或是从 T 派生的类, 那么检测 T 的非显式构造函数, 并由重载决议选择最佳匹配. 然后调用构造函数以初始化该对象.
- 否则, 如果 T 是类类型, 且 其他对象 的类型的无 cv 限定版本不是 T 或从 T 派生, 或如果 T 是非类类型, 但 其他对象 的类型是类类型, 那么检测能从 其他对象 的类型转换到 T（或当 T 是类类型且存在转换函数时, 转换到某个从 T 派生的类型）的用户定义转换序列, 并通过重载决议选择最佳候选. 该转换的结果（如果使用转换构造函数, 那么就是 T 的无 cv 限定版本的右值临时量 (C++11 前)纯右值临时量 (C++11 起)(C++17 前)纯右值表达式 (C++17 起)）会被用于直接初始化该对象. 最后一步通常会被优化掉, 而是将转换结果直接构造于分配给目标对象的内存之中, 但即便不会使用, 也要求适合的构造函数（移动或复制）是可以访问的. (C++17 前)
- 否则（如果 T 和 其他对象 的类型都不是类类型）, 则在需要时用标准转换将 其他对象 的值转换成 T 的无 cv 限定版本.
