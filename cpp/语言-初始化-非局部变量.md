本文参考`非局部变量`文档整理.
https://zh.cppreference.com/w/cpp/language/initialization#.E5.8A.A8.E6.80.81.E5.88.9D.E5.A7.8B.E5.8C.96

## 非局部变量初始化

所有具有`静态存储期`的`非局部变量`的初始化, 会作为`程序启动`的一部分`在 main 函数的执行之前`进行(除非`被延迟`, 见下文). 所有具有`线程存储期`的`非局部变量`的初始化, 会作为`线程启动`的一部分进行, 并按顺序`早于线程函数的执行`开始. 对于这两种变量, 初始化发生于两个截然不同的阶段: `静态初始化` 和 `动态初始化`.

我的总结:

- 是对`静态存储期`和`线程存储期`的`非局部变量`的初始化
- `非局部变量`初始化的`3种`形式: 1,只是`常量初始化`; 2,只是`零初始化`; 3,先是编译期`零初始化`,再是程序启动后`动态初始化`
- `静态初始化`的`常量初始化`发生在`编译期`, 要么被`常量替换`, 要么直接写`常量值`到文件的`.rdata`或`.data`
- `静态初始化`的`零初始化`发生在`编译期`, `非局部变量`地址在`编译期`绑定到`.data`, `加载程序时`由操作系统`以零填充`
- `动态初始化`发生在`程序启动`后, 在`main函数执行前`或`线程函数执行前`

### 静态初始化

静态初始化有两种形式:

1. 如果可能, 就应用`常量初始化`.
2. 否则, `非局部`的静态及线程存储期会被`零初始化`.

实践中:

- `常量初始化`通常在`编译期`进行. 预先被计算的对象表示会作为程序映像的一部分存储下来. 如果编译器没有这样做, 那么它仍然必须保证该初始化发生`早于任何动态初始化`.
- `零初始化`的变量将被置于程序映像的`.bss`段, 它不占据磁盘空间, 并在`加载程序时`由操作系统`以零填充`.

### 动态初始化

在所有`静态初始化`完成后, 在下列情形中进行`非局部变量`的`动态初始化`:

1. `无序的动态初始化`, 仅适用于未被`显式特化`的(静态/线程局域)`类模板`的`静态数据成员`[及`变量模板`(C++14 起)]. 这些`静态变量`的初始化相对于所有其他`动态初始化`之间是`顺序不确定`的[, 除非程序在初始化某个变量之前开始了一个线程, 此时初始化则是`无顺序的` (C++17 起)]. 这些`线程存储期`的初始化相对于所有其他`动态初始化`之间是`无顺序`的.
2. `部分有序的动态初始化`, 适用于并未被`隐式或显式实例化的特化`的所有内联变量. 如果一个`部分有序`的 V 在每个`翻译单元`中比`有序`或`部分有序`的 W 更早定义, 那么 V 的初始化`按顺序早于`(或若程序启动了线程, 则为`先发生于`)W 的初始化. (C++17 起)
3. `有序的动态初始化`, 适用于所有其他`非局部变量`: 在单个`翻译单元`中, 这些变量的`初始化`始终严格以其定义`出现于源代码中的顺序`定序. `不同翻译单元`中的`静态变量`的初始化之间是`顺序不确定`的. `不同翻译单元`中的`线程存储期`的初始化之间是`无顺序`的.

当拥有`静态或线程存储期`的`非局部变量`的初始化通过`异常退出`时, 调用`std::terminate`.

#### 提早动态初始化

在下列条件都满足的情况下, 允许编译器将`动态初始化`的变量的初始化作为`静态初始化`(实为`编译期`)的一部分进行:

1. 初始化的`动态`版本`不改变`命名空间作用域中`任何先于其初始化`的对象的值
2. 初始化的`静态`版本在`被初始化变量中`产生的值, 与当所有不要求`静态初始化`的变量都被`动态初始化`时, 由动态初始化所生成的值相同.

因为上述规则, 如果某对象`o1`的初始化涉及到命名空间作用域对象`o2`, 而它`o2`潜在地要求`动态初始化`, 但在同一翻译单元中在其之后定义, 那么所用的`o2`是`完全初始化`的`o2`的值(因为编译器把`o2`的初始化`提升到编译时`)还是`o2`仅被`零初始化`的值, 是未指明的.

```c++
inline double fd() { return 1.0; }

extern double d1;

double d2 = d1;   // 未指明:
                  // 如果`d1 被动态初始化`则动态初始化为 0.0, 或
                  // 如果`d1 被静态初始化`则动态初始化为 1.0, 或
                  // `静态初始化`为 0.0(因为当`两个变量`都被`动态初始化时`将为这个值)

double d1 = fd(); // 可能静态或动态初始化为`1.0`
```

#### 延迟动态初始化

`动态初始化`是发生`早于`(对于静态变量)主函数或(对于线程存储期)其线程的启动函数的`首条语句`, 还是`延迟到发生晚于`它们, 是由实现定义的.

如果[`非内联变量`的 (C++17 起)]初始化`延迟到发生晚于`主/线程函数的首条语句, 那么它发生`早于`与所初始化的变量定义于同一翻译单元中的任何拥有静态/线程存储期的变量的`首次 ODR 使用`. 若给定翻译单元中`没有 ODR 使用`变量或函数, 则定义于该翻译单元的非局部变量`可能始终不被初始化`(这模仿按需的动态库的行为). 然而, 只要翻译单元中 ODR 使用了任何事物, 就会初始化所有在初始化或销毁中拥有副作用的非局部变量, 即使程序中没有用到它们.

如果`内联变量`的初始化被延迟, 那么它发生早于这个特定变量的首次 ODR 使用. (C++17 起)

```c++
// ============
// == 文件 1 ==

#include "a.h"
#include "b.h"

B b;
A::A() { b.Use(); }

// ============
// == 文件 2 ==

#include "a.h"

A a;

// ============
// == 文件 3 ==

#include "a.h"
#include "b.h"

extern A a;
extern B b;

int main()
{
    a.Use();
    b.Use();
}

// 如果 a 在进入 main 之前被初始化, 那么 b 可能在 A::A() 使用它的时间点仍未被初始化
// (因为动态初始化在翻译单元间是顺序不确定的)

// 如果 a 在某个 main 的首条语句之后的时间点初始化
// (它 ODR 使用了定义于文件 1 的函数, 强制其初始化得以运行),
// 那么 b 将在 A::A 使用它前初始化
```
