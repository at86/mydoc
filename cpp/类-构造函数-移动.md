本文参考cppreference 上的`移动构造函数`说明
https://zh.cppreference.com/w/cpp/language/move_constructor

语法
类名 (形参列表 ); (1)

类名 (形参列表 ) 函数体  (2)

类名 (单形参列表 ) = default;  (3)

类名 (形参列表 ) = delete;  (4)

类名 ::类名 (形参列表 ) 函数体 (5)

类名 ::类名 (单形参列表 ) = default; (6)



类名  - 要声明移动构造函数的类

形参列表  - 满足以下条件的非空形参列表：

给定该类的类型为 T，第一个形参的类型是 T&&，const T&&，volatile T&& 或 const volatile T&&，并且

要么没有其他形参，要么其他形参都有默认实参

单形参列表 - 只有一个形参的形参列表，该形参没有默认实参，并且类型是 T&&，const T&&，volatile T&& 或 const volatile T&&

函数体 - 移动构造函数的函数体


1) 类定义中的移动构造函数的声明。

2-4) 类定义中的移动构造函数的定义。

3) 移动构造函数会被显式预置。

4) 移动构造函数会被弃置。

5,6) 类定义之外的移动构造函数的定义（该类必须包含一条声明 (1)）。

6) 移动构造函数会被显式预置。



struct X
{
    X(X&& other); // 移动构造函数
//  X(X other);   // 错误：形参类型不正确
};

struct Y
{
    Y(Y&& other, int num = 1); // 有多个形参的移动构造函数
//  Y(Y&& other, int num);     // 错误：num 没有默认实参
};


简介
    移动构造函数是提供一个相同类类型实参就能调用，并且在可能会修改实参的情况下，复制该实参的内容的构造函数。

    当从同类型的 `右值（亡值或纯右值） (C++17 前)`  `亡值 (C++17 起)` 初始化（直接初始化或复制初始化）对象时，会调用移动构造函数，情况包括：

初始化：T a = std::move(b); 或 T a(std::move(b));，其中 b 的类型是 T ；

函数实参传递：f(std::move(a));，其中 a 的类型是 T 且 f 是 Ret f(T t) ；

函数返回：在像 T f() 这样的函数中的 return a;，其中 a 的类型是 T，且 T 有移动构造函数。

    当初始化器是纯右值时，`通常会优化掉 (C++17 前)`  `始终不会进行 (C++17 起)` 对移动构造函数的调用，见复制消除。



例子
#include "pch.h"
#include "CsFvLang.h"

void CsFvLang::ClassMoveConstructor() {
    at_mlog("====== ClassMoveConstructor 移动构造函数 ======\n");
    struct A {
        std::string s;
        int k;
        A() : s("测试"), k(-1) {
            at_mtrace("A 默认构造\n");
        }
        A(const A& o) : s(o.s), k(o.k) {
            at_mtrace("A 复制构造, 移动失败！\n");
        }
        A(A&& o) noexcept
            : s(std::move(o.s)),  // 类类型成员的显式移动
              k(std::exchange(o.k, 0))  // 非类类型成员的显式移动
        {
            at_mtrace("A 移动构造\n");
        }
    };
    auto f = [](A a) { return a; };
    struct B : A {
        std::string s2;
        int n;
        // 隐式移动构造函数 B::(B&&)
        // 调用 A 的移动构造函数
        // 调用 s2 的移动构造函数
        // 并进行 n 的逐位复制
    };
    struct C : B {
        ~C() {}  // 析构函数阻止隐式移动构造函数 C::(C&&)
    };
    struct D : B {
        D() {}
        ~D() {}  // 析构函数阻止隐式移动构造函数 D::(D&&)
        D(D&&) = default;  // 强制生成移动构造函数
    };

    at_mtrace("==> 尝试移动 A\n");
    A a1 = f(A());  // 按值返回时，从函数形参移动构造它的目标
    at_mtrace("移动前，a1.s=%s, a1.k=%d\n", a1.s.c_str(), a1.k);
    A a2 = std::move(a1);  // 从亡值移动构造
    at_mtrace("移动后，a1.s=%s, a1.k=%d\n", a1.s.c_str(), a1.k);

    at_mtrace("==> 尝试移动 B\n");
    B b1{};
    at_mtrace("移动前，b1.s=%s, b1.n=%d\n", b1.s.c_str(), b1.n);
    B b2 = std::move(b1);  // 调用隐式移动构造函数
    at_mtrace("移动后，b1.s=%s\n", b1.s.c_str());

    at_mtrace("==> 尝试移动 C\n");
    C c1{};
    C c2 = std::move(c1);  // 调用复制构造函数

    at_mtrace("==> 尝试移动 D\n");
    D d1{};
    D d2 = std::move(d1);
}


输出

L40 : ==> 尝试移动 A
L10 : A 默认构造
L19 : A 移动构造
L42 : 移动前，a1.s=测试, a1.k=-1
L19 : A 移动构造
L44 : 移动后，a1.s=, a1.k=0
L46 : ==> 尝试移动 B
L10 : A 默认构造
L48 : 移动前，b1.s=测试, b1.n=0
L19 : A 移动构造
L50 : 移动后，b1.s=
L52 : ==> 尝试移动 C
L10 : A 默认构造
L13 : A 复制构造, 移动失败！
L56 : ==> 尝试移动 D
L10 : A 默认构造
L19 : A 移动构造


解释

    典型的移动构造函数“窃取”实参曾保有的资源（例如指向动态分配对象的指针，文件描述符，TCP socket，输入输出流，运行的线程，等等），而非复制它们，并使它的实参遗留在某个合法但不确定的状态。例如，从 std::string 或从 std::vector 移动可以导致实参被置为空。但是不应该依赖此类行为。对于某些类型，例如 std::unique_ptr，移动后的状态是完全指定的。



## 隐式声明的移动构造函数

    如果不对类类型提供任何用户定义的移动构造函数，且满足下列所有条件：

没有用户声明的复制构造函数；

没有用户声明的复制赋值运算符；

没有用户声明的移动赋值运算符；

没有用户声明的析构函数；

    那么编译器将声明一个移动构造函数作为这个类的非 explicit 的 inline public 成员，签名是 T::T(T&&)。



    一个类可以拥有多个移动构造函数，例如 T::T(const T&&) 和 T::T(T&&)。当存在用户定义的移动构造函数时，用户仍然可以通过关键词 default 强制编译器生成隐式声明的移动构造函数。



    隐式声明（或在它的首个声明被预置）的移动构造函数具有动态异常说明 (C++17 前)noexcept 说明 (C++17 起)中所描述的异常说明。



## 隐式定义的移动构造函数

    如果隐式声明的移动构造函数没有被弃置也不平凡，那么当它被 ODR 式使用或用于常量求值时，它会被编译器定义（生成并编译函数体）。对于联合体类型，隐式定义的移动构造函数（如同以 std::memmove）复制它的对象表示。对于非联合类类型，该构造函数用以亡值实参执行的直接初始化，按照初始化顺序，对对象的各基类和非静态成员进行完整的逐对象移动。如果它满足对于 constexpr 构造函数的要求，那么生成的移动构造函数也是 constexpr 的。



    如果它满足对于 constexpr 构造函数 (C++23 前)constexpr 函数 (C++23 起)的要求，那么生成的移动构造函数也是 constexpr 的。



## 弃置的移动构造函数

    类 T 中隐式声明的或显式预置的移动构造函数在它有一个具有类类型 M（或它的可以有多维的数组类型）的潜在构造的子对象，并且满足以下任意条件，那么该移动构造函数被定义为弃置的：

M 有一个被弃置或无法从该默认构造函数访问的析构函数。

为寻找 M 的移动构造函数而进行的重载决议

没有产生可用候选，或者

在该子对象是变体成员时，选择了非平凡的函数。



    重载决议会忽略被弃置的预置移动构造函数（否则它会阻止从右值复制初始化）。



## 平凡的移动构造函数

如果满足下列所有条件，类 T 移动构造函数是平凡的：

它不是用户提供的（即它是隐式定义或预置的）；

T 没有虚成员函数；

T 没有虚基类；

为 T 的每个直接基类选择的移动构造函数都是平凡的；

为 T 的每个类类型（或类类型数组）的非静态成员选择的移动构造函数都是平凡的。



    平凡的移动构造函数是与平凡的复制构造函数实施相同动作的构造函数，即它如同用 std::memmove 来进行对象表示的复制。所有与 C 兼容的数据类型（POD 类型）都可以平凡移动。



## 合格的移动构造函数

    没有被弃置的移动构造函数是合格的。 (C++20 前)

    满足下列所有条件的移动构造函数是合格的：(C++20 起)

它没有被弃置，且

满足它的所有关联约束（如果存在），且

没有比它更受约束且拥有相同的第一形参类型的移动构造函数。



    合格的移动构造函数的平凡性确定该类是否为隐式生存期类型，以及该类是否为可平凡复制类型。



## 注解

    为使强异常保证可行，用户定义的移动构造函数不应该抛出异常。例如，std::vector 在需要重新放置元素时，基于 std::move_if_noexcept 在移动和复制之间选择。



    如果同时提供了复制和移动构造函数而没有其他可行的构造函数，那么重载决议在实参是相同类型的右值（如 std::move 的结果的亡值，或如无名临时量的纯右值）时选择移动构造函数，而在实参是左值（具名对象或返回左值引用的函数/运算符）时选择复制构造函数。如果只提供复制构造函数，那么重载决议对于所有实参类别都会选择它（只要它接收到 const 的引用，因为右值能绑定到 const 引用），这使得复制可以作为在移动不可用时的后备。



    当接收右值引用为它的形参时，构造函数被称作“移动构造函数”。它没有义务移动任何内容，不要求类拥有要被移动的资源，而且在受允许（但可能没意义）的以 const 右值引用（const T&&）为形参的情况中，‘移动构造函数’可能无法移动资源。
